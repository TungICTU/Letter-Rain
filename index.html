<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Letter Rain - Fun Physics Word Game (Mobile Friendly)</title>
  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <style>
  :root{
    --bg:#071226;
    --card:#071627;
    --muted:#9aa8bf;
    --accent:#7dd3fc;
    --accent-2:#60a5fa;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{ height:100%; margin:0; background:linear-gradient(180deg,#021024 0%,#071226 100%); color:#e6f6ff; display:flex; align-items:center; justify-content:center; }
  .game-shell{ width:940px; max-width:96vw; display:grid; grid-template-columns:1fr 320px; gap:18px; align-items:start; transition:all .24s ease; }
  .panel{ background:var(--card); padding:18px; border-radius:12px; box-shadow:0 10px 40px rgba(4,9,20,0.6); border:1px solid rgba(255,255,255,0.03); }
  .left{ display:flex; align-items:center; justify-content:center; position:relative; padding:18px; flex-direction:column; }
  #play-wrap{ width:580px; height:660px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); overflow:hidden; position:relative; touch-action:none; }
  canvas { width:100%; height:100%; display:block; touch-action:none; }
  .hint{ position:absolute; left:12px; top:12px; font-size:13px; color:var(--muted); z-index:6; }
  .right{ width:320px; }
  h1{ margin:0; font-size:20px; color:#e6f6ff; }
  .muted{ color:var(--muted); font-size:13px; }
  .stat{ display:flex; justify-content:space-between; align-items:center; background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; margin-top:12px; }
  .big{ font-weight:700; font-size:28px; color:#e6f6ff; }
  .controls{ margin-top:14px; display:flex; gap:10px; }
  button.btn{ background:linear-gradient(180deg,var(--accent),var(--accent-2)); border:none; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; color:#013; }
  button.ghost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); padding:10px 12px; border-radius:10px; cursor:pointer; }
  .ghost.active{ background: linear-gradient(180deg, rgba(125,211,252,0.12), rgba(96,165,250,0.08)); border: 1px solid rgba(125,211,252,0.12); color: #7dd3fc; }
  .words-list{ margin-top:16px; max-height:280px; overflow:auto; padding-right:8px; }
  footer.note{ margin-top:12px; font-size:12px; color:var(--muted); }
  .level-wrap{ margin-top:12px; }
  .level-row{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .level-bar{ margin-top:8px; width:100%; height:12px; background:rgba(255,255,255,0.04); border-radius:8px; overflow:hidden; }
  .level-bar-inner{ height:100%; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); border-radius:8px; transition:width 300ms ease; }
  .level-text{ font-size:13px; color:var(--muted); }

  /* Combo UI - positioned below the play area and non-interactive so it won't block canvas */
  .combo-wrap{ margin-top:12px; width:100%; pointer-events:none; }
  .combo-row{ display:flex; align-items:center; gap:8px; }
  .combo-text{ font-weight:700; color:#ffd27a; font-size:13px; width:110px; pointer-events:none; }
  .combo-bar{ flex:1; height:10px; background:rgba(255,255,255,0.03); border-radius:8px; overflow:hidden; }
  .combo-bar-inner{ height:100%; width:0%; background:linear-gradient(90deg,#ffd27a,#ffb86b); transition:width 120ms linear; pointer-events:none; }

  /* Mobile-friendly tweaks */
  @media (max-width:980px){
    .game-shell{ grid-template-columns:1fr; gap:12px; padding:12px; width:100%; max-width:100vw; }
    .right{ width:88vw; max-width:420px; position:fixed; right:12px; top:88px; bottom:12px; transform:translateY(20px) translateX(120%); transition:transform .28s cubic-bezier(.2,.9,.2,1); z-index:9998; box-shadow:0 20px 60px rgba(2,6,23,0.8); display:block; }
    .right.open{ transform: translateX(0) translateY(0); }
    /* overlay that will dim when panel open */
    .mobile-overlay{ position:fixed; left:0; right:0; top:0; bottom:0; background:rgba(0,0,0,0.36); z-index:9997; display:none; }
    .mobile-overlay.show{ display:block; }

    /* reduce play area height to better fit smaller screens */
    #play-wrap{ width:100%; height:56vh; min-height:360px; border-radius:14px; padding:6px; }
    .controls{ flex-wrap:wrap; gap:8px; }
    .controls button{ flex:1 1 48%; min-width:120px; }
    button.btn{ padding:12px 16px; font-size:16px; border-radius:12px; }
    button.ghost{ padding:12px 16px; font-size:15px; border-radius:12px; }
    .muted{ font-size:14px; }
    .level-text{ font-size:13px; }
    .words-list{ max-height:180px; }
    footer.note{ font-size:13px; }
    /* move combo UI slightly larger for touch readability */
    .combo-text{ font-size:14px; }
    .combo-bar{ height:12px; }

    /* Mobile-specific UI container */
    .mobile-ui{ display:block; width:100%; margin-bottom:10px; }
    .mobile-toprow{ display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:8px; }
    .mobile-top-card{ background:linear-gradient(180deg, rgba(2,6,23,0.72), rgba(2,6,23,0.6)); padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); display:flex; gap:8px; align-items:center; min-width:60px; }
    .mobile-top-left{ display:flex; gap:8px; align-items:center; }
    .mobile-mid{ margin-bottom:8px; }
    .mobile-level-row{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .mobile-progress{ margin-top:6px; }
    .mobile-stats{ display:flex; justify-content:space-between; gap:8px; margin-bottom:8px; }

    /* Floating HUD hidden when mobile-ui is shown */
    #floatingHud{ display:none !important; }

    /* Floating HUD on mobile removed in favor of mobile-ui */
    .hud-card{ display:none; }
    /* hide the extra floating menu button on mobile (use in-panel Menu instead) */
    .sidebar-toggle{ display:none; }
  }

  /* Larger devices: increase hit target slightly */
  @media (min-width:981px){
    button.btn{ padding:12px 16px; }
  }

  /* small polish for readability of recent words list */
  .words-list p{ margin:6px 0; line-height:1.2; }
  </style>
</head>
<body>
  <!-- Mobile overlay (for off-canvas right panel) -->
  <div id="mobileOverlay" class="mobile-overlay" tabindex="-1" aria-hidden="true"></div>

  <!-- Sidebar toggle button (kept but hidden on mobile) -->
  <button id="sidebarToggle" class="sidebar-toggle" style="display:none;">Menu</button>

  <div class="game-shell" id="gameShell">
    <div class="panel left">
      <!-- MOBILE UI: visible only on small screens -->
      <div class="mobile-ui" id="mobileUI" style="display:none;">
        <div class="mobile-toprow">
          <div class="mobile-top-left">
            <div class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Score</div><div id="hudScore" style="font-weight:700;margin-left:6px;">0</div></div>
            <div class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Time</div><div id="hudTimer" style="font-weight:700;margin-left:6px;">00:00</div></div>
          </div>
          <!-- menu button uses existing sidebarToggle for consistency -->
          <div><button id="mobileMenuBtn" class="ghost" style="padding:8px 10px;">Menu</button></div>
        </div>

        <div class="mobile-mid">
          <div class="mobile-level-row">
            <div style="font-weight:700">Level <span id="mobileLevelNum">1</span></div>
            <div class="level-text" id="mobileLevelProgressText">Progress: 0/100</div>
          </div>
          <div class="level-bar mobile-progress" aria-hidden="true"><div id="mobileLevelBarInner" class="level-bar-inner"></div></div>
        </div>

        <div class="mobile-stats">
          <div style="min-width:40%;" class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Words</div><div id="mobileWordsCount" style="font-weight:700;margin-left:6px;">0</div></div>
          <div style="min-width:40%;" class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Letters</div><div id="mobileLettersCount" style="font-weight:700;margin-left:6px;">0</div></div>
        </div>
      </div>

      <div id="play-wrap" aria-label="game area">
        <canvas id="gameCanvas"></canvas>
      </div>

      <!-- combo bar placed below the play-wrap (non-interactive so it won't block gameplay) -->
      <div class="combo-wrap" id="comboWrap" style="display:none;" aria-hidden="true">
        <div class="combo-row">
          <div class="combo-text" id="comboText">Combo x0</div>
          <div class="combo-bar" aria-hidden="true"><div id="comboBarInner" class="combo-bar-inner"></div></div>
        </div>
      </div>

      <!-- MOBILE BUTTONS (duplicates that call same actions) -->
      <div id="mobileButtons" style="display:none;margin-top:10px;gap:8px;">
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button id="mobileStartBtn" class="btn">Start</button>
          <button id="mobilePauseBtn" class="ghost">Pause</button>
          <button id="mobileHintBtn" class="ghost">Hint</button>
          <button id="mobileConnectToggle" class="ghost" aria-pressed="false">Connect Mode</button>
        </div>
      </div>

    </div>

     <div class="panel right" id="rightPanel" role="region" aria-label="Game controls">
      <h1>Letter Rain — Connected Touch Anagrams (Mobile Friendly)</h1>
      <div class="muted" id="controlsNote">Hold <strong>Shift</strong> + left-click and drag to connect letters <em>in order</em> (letters must touch). Release to submit the sequence as a word.</div>

      <div class="stat" style="margin-top:16px;">
        <div>
          <div style="font-size:12px;color:var(--muted)">Score</div>
          <div id="score" class="big">0</div>
        </div>
        <div style="text-align:right;">
          <div style="font-size:12px;color:var(--muted)">Time</div>
          <div id="timer" class="big">00:00</div>
        </div>
      </div>

      <div class="controls">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="ghost">Pause</button>
        <button id="hintBtn" class="ghost">Hint</button>
        <!-- Connect mode toggle for mobile -->
        <button id="connectToggle" class="ghost" aria-pressed="false">Connect Mode</button>
      </div>

      <div class="level-wrap">
        <div class="level-row">
          <div style="font-weight:700">Level <span id="levelNum">1</span></div>
          <div class="level-text" id="levelProgressText">Words: 0/3</div>
        </div>
        <div class="level-bar" aria-hidden="true">
          <div id="levelBarInner" class="level-bar-inner"></div>
        </div>
      </div>

      <div style="display:flex;gap:10px;margin-top:12px;flex-wrap:wrap;">
        <div style="flex:1;min-width:120px;">
          <div style="font-size:12px;color:var(--muted)">Words matched</div>
          <div id="wordsCount" style="font-weight:700">0</div>
        </div>
        <div style="flex:1;min-width:120px;text-align:right;">
          <div style="font-size:12px;color:var(--muted)">Letters remaning</div>
          <div id="lettersCount" style="font-weight:700">0</div>
        </div>
      </div>

      <div class="words-list" id="recentWords"><p class="muted">No words yet.</p></div>

      <footer class="note">Drag letters to reposition them (without Shift). Hold <strong>Shift</strong> to connect letters in order. On touch devices: long-press or enable Connect Mode.</footer>
    </div>
  </div>
 <script>
/* Mobile-friendly additions:
   - Auto-enable Connect Mode on touch / small screens
   - Hide the Connect toggle when auto-enabled
   - Show a one-time mobile hint overlay
   - Slightly increase touch hit targets via CSS (above)
   - Fixed touch dragging so moving after touch starts a drag
*/

/* ---------------------- CONFIG ---------------------- */
const CONFIG = {
  letterSpawnInterval: 50, // not used for continuous spawning anymore
  maxLetters: 30,
  initialFillCount: 30,
  fillBurstInterval: 22,
  letterSize: 60,
  gravity: 0.5,
  wordMinLength: 2,
  scorePerLetter: 10,
  spawnHorizontalPadding: 30,
  fadeDuration: 300,
  detectEveryMs: 100,
  flashPauseMs: 520,
  levelBaseScore: 100,
  levelScoreIncrement: 50,
  levelScoreIncrementGrowth: 10,
  spawnDecreasePerLevel: 120,
  minSpawnInterval: 50,
  removeFractionOnLevel: 0.50,
  pointsPerRemovedLetter: 5,
  maxParticles: 600,
  // HINT config
  hintMaxDepth: 8,
  hintMaxNodes: 20000,
  hintSearchMillisPerMode: 300, // ms per search pass
  hintHighlightMs: 4200,
  // COMBO config
  comboStartThreshold: 3, // matches required to start giving combo bonus
  comboBonuses: [0,0,0,10,20,30,40], // index by streak count (0..6), 7+ -> 50
  comboMaxBonusFrom7: 50,
  comboDurationAt3: 30, // seconds at 3rd
  comboDurationDecreasePerLevel: 5, // each level up
  comboDurationMin: 10, // minimum seconds from 7th
};

/* ---------------------- DICTIONARY (array kept only temporarily for build) ---------------------- */
const DICTIONARY_ARRAY = [ ];

/* ---------------------- TRIE (memory-friendly) ---------------------- */
class TrieNode { constructor(){ this.children = Object.create(null); this.isWord = false; } }
class Trie { constructor(){ this.root = new TrieNode(); } insert(word){ let node = this.root; for (let i=0;i<word.length;i++){ const ch = word[i]; if (!node.children[ch]) node.children[ch] = new TrieNode(); node = node.children[ch]; } node.isWord = true; } contains(word){ let node = this.root; for (let i=0;i<word.length;i++){ const ch = word[i]; node = node.children[ch]; if (!node) return false; } return !!node.isWord; } isPrefix(pref){ let node = this.root; for (let i=0;i<pref.length;i++){ const ch = pref[i]; node = node.children[ch]; if (!node) return false; } return true; } }
const trie = new Trie(); (function buildTrieFromArray(){ if (Array.isArray(DICTIONARY_ARRAY) && DICTIONARY_ARRAY.length){ for (let i = 0; i < DICTIONARY_ARRAY.length; i++){ trie.insert(String(DICTIONARY_ARRAY[i]).toLowerCase()); } try { DICTIONARY_ARRAY.length = 0; } catch(e){} } })();

/* ---------------------- UTIL ---------------------- */
const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

/* ---------------------- DOM & STATE ---------------------- */
const playWrap = document.getElementById('play-wrap');
const canvas = document.getElementById('gameCanvas');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const hintBtn = document.getElementById('hintBtn');
const wordsCountEl = document.getElementById('wordsCount');
const lettersCountEl = document.getElementById('lettersCount');
const recentWordsEl = document.getElementById('recentWords');
const levelNumEl = document.getElementById('levelNum');
const levelProgressTextEl = document.getElementById('levelProgressText');
const levelBarInnerEl = document.getElementById('levelBarInner');

// combo UI
const comboWrap = document.getElementById('comboWrap');
const comboTextEl = document.getElementById('comboText');
const comboBarInnerEl = document.getElementById('comboBarInner');

const rightPanel = document.getElementById('rightPanel');
const sidebarToggle = document.getElementById('sidebarToggle');
const mobileOverlay = document.getElementById('mobileOverlay');

// floating/mobile HUD elements
const hudScore = document.getElementById('hudScore');
const hudTimer = document.getElementById('hudTimer');
const mobileUI = document.getElementById('mobileUI');
const mobileLevelNum = document.getElementById('mobileLevelNum');
const mobileLevelProgressText = document.getElementById('mobileLevelProgressText');
const mobileLevelBarInner = document.getElementById('mobileLevelBarInner');
const mobileWordsCount = document.getElementById('mobileWordsCount');
const mobileLettersCount = document.getElementById('mobileLettersCount');
const mobileButtons = document.getElementById('mobileButtons');

const mobileStartBtn = document.getElementById('mobileStartBtn');
const mobilePauseBtn = document.getElementById('mobilePauseBtn');
const mobileHintBtn = document.getElementById('mobileHintBtn');
const mobileMenuBtn = document.getElementById('mobileMenuBtn');
const mobileConnectToggle = document.getElementById('mobileConnectToggle');

// ----------------- CONNECT MODE (pinned + transient Shift) -----------------
// Replaces the old single `connectMode` boolean with pinned + transient states.
const connectToggle = document.getElementById('connectToggle');
let pinnedConnectMode = false;      // toggled by the Connect button
let transientConnectMode = false;   // temporarily true while Shift is held

function effectiveConnectModeForEvent(evt){
  // Use pinned OR transient OR event.shiftKey (useful when key events might not fire for the pointer's context)
  return pinnedConnectMode || transientConnectMode || (!!(evt && evt.shiftKey));
}
function effectiveConnectMode(){
  return pinnedConnectMode || transientConnectMode;
}
function updateConnectToggleUI(){
  const active = effectiveConnectMode();
  connectToggle.classList.toggle('active', active);
  mobileConnectToggle && mobileConnectToggle.classList.toggle('active', active);
  // aria-pressed represents the pinned state (true if pinned on)
  connectToggle.setAttribute('aria-pressed', String(pinnedConnectMode));
  if (mobileConnectToggle) mobileConnectToggle.setAttribute('aria-pressed', String(pinnedConnectMode));
  connectToggle.textContent = active ? 'Connect: On' : 'Connect Mode';
  if (mobileConnectToggle) mobileConnectToggle.textContent = active ? 'Connect: On' : 'Connect Mode';
}
function togglePinnedConnectMode(){
  pinnedConnectMode = !pinnedConnectMode;
  updateConnectToggleUI();
}
// button toggles pinned state
connectToggle.addEventListener('click', (ev) => {
  togglePinnedConnectMode();
});

// Keyboard listeners to set transientConnectMode when Shift is pressed/released.
// This makes holding Shift behave like "temporarily enable Connect Mode".
window.addEventListener('keydown', (ev) => {
  if (ev.key === 'Shift' && !transientConnectMode){
    transientConnectMode = true;
    updateConnectToggleUI();
  }
});
window.addEventListener('keyup', (ev) => {
  if (ev.key === 'Shift' && transientConnectMode){
    transientConnectMode = false;
    updateConnectToggleUI();
  }
});
// wire mobile connect toggle to the same action
if (mobileConnectToggle) mobileConnectToggle.addEventListener('click', () => { togglePinnedConnectMode(); });
// --------------------------------------------------------------------------

let engine, world, render, runner;
let running = false;
let startTime = null;
let elapsedTimer = null;

/* Scores */
let score = 0;           // total, displayed in UI
let progressScore = 0;   // counts toward level progression only
let wordsMatched = [];
let lettersOnScreen = 0;
let spawnCount = 0;
let gameOver = false;

/* Level state */
let level = 1;

/* Dragging state */
let pointer = { x:0, y:0, isDown:false };
let dragging = { body: null, lastPos: null, lastTime: null };

/* Selection (SHIFT-drag) state */
let selectionActive = false;
let selection = { bodies: [], lastBody: null };

/* Animation flag */
let animationPlaying = false;

/* Adjacency graph: body -> Set(neighbors) */
const adjacency = new Map();

/* Glyph cache for A-Z (offscreen canvases) */
const glyphs = {};
function createGlyph(letter){
  const size = CONFIG.letterSize;
  const oc = document.createElement('canvas');
  oc.width = size; oc.height = size;
  const ctx = oc.getContext('2d');
  ctx.beginPath();
  ctx.arc(size/2, size/2, size/2 - 1, 0, Math.PI*2);
  ctx.fillStyle = '#0ea5e9';
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.stroke();
  ctx.fillStyle = '#0b1320';
  ctx.font = `bold ${Math.round(size * 0.68)}px Inter, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(letter, size/2, size/2 + 1);
  ctx.fillStyle = '#f8fdff';
  ctx.fillText(letter, size/2 + 0, size/2);
  return oc;
}
(function prepareGlyphs(){
  const A = 'A'.charCodeAt(0);
  for (let i=0;i<26;i++){ const ch = String.fromCharCode(A + i); glyphs[ch] = createGlyph(ch); }
})();

/* Particles & Floating Status */
const particles = [];
const floatingStatuses = [];
function spawnParticle(x,y, color){
  const angle = Math.random() * Math.PI * 2;
  const speed = 0.6 + Math.random() * 3.4;
  const life = 400 + Math.random() * 400;
  particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - 1.2, life, start: performance.now(), color, size: 2 + Math.random()*3 });
  if (particles.length > CONFIG.maxParticles) particles.splice(0, particles.length - CONFIG.maxParticles);
}
function spawnExplosion(x,y,count,color){
  const capped = Math.min(count, 80);
  for (let i=0;i<capped;i++) spawnParticle(x + (Math.random()-0.5)*6, y + (Math.random()-0.5)*6, color || '#fff');
}
function showFloatingStatus(text, x, y, opts = {}){
  let safeText = String(text || '').slice(0, 60);
  const now = performance.now();
  const obj = { text: safeText, x: x || (render ? render.options.width/2 : 200), y: y || (render ? render.options.height/2 : 200), start: now, duration: opts.duration || 1400, color: opts.color || '#e6f6ff', size: opts.size || 18 };
  floatingStatuses.push(obj);
}

/* ---------------------- MATTER SETUP ---------------------- */
function initMatter(){
  if (engine) return;
  engine = Matter.Engine.create();
  world = engine.world;
  world.gravity.y = CONFIG.gravity;
  render = Matter.Render.create({
    canvas: canvas,
    engine: engine,
    options: {
      width: playWrap.clientWidth,
      height: playWrap.clientHeight,
      wireframes: false,
      background: 'transparent',
      pixelRatio: (window.devicePixelRatio || 1),
      showVelocity: false
    }
  });
  runner = Matter.Runner.create();
  Matter.Render.run(render);
  Matter.Runner.run(runner, engine);
  updateBoundaries();
  Matter.Events.on(render, 'afterRender', drawLetters);
  Matter.Events.on(engine, 'collisionStart', handleCollisions);
  Matter.Events.on(engine, 'collisionActive', handleCollisions);
  Matter.Events.on(engine, 'collisionEnd', handleCollisionEnd);
  window.addEventListener('resize', updateBoundaries);
}

/* Boundaries */
let walls = [];
function updateBoundaries(){
  if (!playWrap || !render) return;
  const w = playWrap.clientWidth, h = playWrap.clientHeight;
  for (const b of walls) try{ Matter.World.remove(world, b); } catch(e){}
  walls = [];
  const t = 60;
  const left = Matter.Bodies.rectangle(-t/2, h/2, t, h, { isStatic:true, render:{visible:false} });
  const right = Matter.Bodies.rectangle(w + t/2, h/2, t, h, { isStatic:true, render:{visible:false} });
  const bottom = Matter.Bodies.rectangle(w/2, h + t/2, w + t*2, t, { isStatic:true, render:{visible:false} });
  walls.push(left, right, bottom);
  Matter.World.add(world, walls);

  // handle HiDPI canvas sizing
  const pr = render.options.pixelRatio || 1;
  render.canvas.style.width = w + 'px';
  render.canvas.style.height = h + 'px';
  render.canvas.width = Math.round(w * pr);
  render.canvas.height = Math.round(h * pr);

  // ensure drawing is in CSS pixels (scale context to pixel ratio)
  const ctx = render.context;
  ctx.setTransform(pr, 0, 0, pr, 0, 0);

  render.options.width = w;
  render.options.height = h;
}

/* Collision event handlers to update adjacency */
function ensureAdjEntry(b){ if (!adjacency.has(b)) adjacency.set(b, new Set()); }
function addEdge(a,b){ ensureAdjEntry(a); ensureAdjEntry(b); adjacency.get(a).add(b); adjacency.get(b).add(a); }
function removeEdge(a,b){ if (adjacency.has(a)) adjacency.get(a).delete(b); if (adjacency.has(b)) adjacency.get(b).delete(a); }
function clearEdgesForBody(b){ const neighbors = adjacency.get(b); if (!neighbors) return; for (const other of Array.from(neighbors)){ if (adjacency.has(other)) adjacency.get(other).delete(b); } adjacency.delete(b); }
function handleCollisions(ev){ for (const pair of ev.pairs){ const a = pair.bodyA, b = pair.bodyB; if (a.label === 'letter' && b.label === 'letter' && !a.isRemoved && !b.isRemoved){ addEdge(a,b); } } }
function handleCollisionEnd(ev){ for (const pair of ev.pairs){ const a = pair.bodyA, b = pair.bodyB; if (a.label === 'letter' && b.label === 'letter'){ removeEdge(a,b); } } }

/* ---------------------- SPAWN LETTER ---------------------- */
function spawnLetter(letter){
  const w = playWrap.clientWidth, h = playWrap.clientHeight;
  const diameter = CONFIG.letterSize, radius = diameter/2;
  const x = randInt(CONFIG.spawnHorizontalPadding + radius, w - CONFIG.spawnHorizontalPadding - radius);
  const y = radius + 6;
  const body = Matter.Bodies.circle(x, y, radius, {
    restitution: 0.45,
    friction: 0.02,
    frictionAir: 0.02,
    label: 'letter',
    letter: (typeof letter === 'string' && letter.length>0) ? letter.toUpperCase() : 'A',
    spawnId: ++spawnCount,
    render: { visible:false }
  });
  Matter.Body.setDensity(body, 0.001 + Math.random()*0.002);
  Matter.World.add(world, body);
  lettersOnScreen++; lettersCountEl.textContent = lettersOnScreen; if (mobileLettersCount) mobileLettersCount.textContent = lettersOnScreen;
  return body;
}

/* Spawn until CONFIG.maxLetters (burst) — used after leveling up */
function spawnUntilMax(){
  return new Promise(resolve => {
    if (!running) { resolve(); return; }
    const target = CONFIG.maxLetters;
    const iv = setInterval(()=> {
      if (!running) { clearInterval(iv); resolve(); return; }
      if (lettersOnScreen >= target){
        clearInterval(iv);
        resolve();
        return;
      }
      const letter = String.fromCharCode(65 + Math.floor(Math.random()*26));
      spawnLetter(letter);
    }, CONFIG.fillBurstInterval);
  });
}

/* Burst-fill the box at game start */
function fillInitialLetters(){
  const target = Math.min(CONFIG.initialFillCount, CONFIG.maxLetters);
  const iv = setInterval(()=> {
    if (!running) { clearInterval(iv); return; }
    if (lettersOnScreen >= target){ clearInterval(iv); return; }
    const letter = String.fromCharCode(65 + Math.floor(Math.random()*26));
    spawnLetter(letter);
  }, CONFIG.fillBurstInterval);
}

/* ---------------------- DRAW (use glyph cache) ---------------------- */
function drawLetters(){
  try {
    const ctx = render.context;
    ctx.clearRect(0,0, render.canvas.width, render.canvas.height);
    const bodies = Matter.Composite.allBodies(world);
    const now = performance.now();

    // draw letter glyphs (only valid letter bodies)
    for (const b of bodies){
      try {
        if (b.label === 'letter' && typeof b.letter === 'string' && !b.isRemoved){
          const ch = (b.letter || 'A').toUpperCase();
          const glyph = glyphs[ch] || glyphs['A'];
          const size = CONFIG.letterSize;
          const alpha = (b.__fadeAlpha !== undefined) ? b.__fadeAlpha : 1;
          ctx.globalAlpha = alpha;
          ctx.drawImage(glyph, b.position.x - size/2, b.position.y - size/2, size, size);
        }
      } catch(e){ /* swallow drawing error for that body */ }
    }

    // selection/flash overlays (safely)
    for (const b of bodies){
      try {
        // HINT HIGHLIGHT (pulsing ring)
        if (b.__hint && !b.isRemoved){
          ctx.save();
          const t = ((now % 1200) / 1200);
          const pulse = 1 + (Math.sin(t * Math.PI * 2) * 0.06);
          const r = (b.circleRadius || CONFIG.letterSize / 2) * pulse + 4;
          ctx.lineWidth = 3;
          ctx.strokeStyle = '#ffd27a';
          ctx.beginPath();
          ctx.globalAlpha = 0.95;
          ctx.arc(b.position.x, b.position.y, r, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // STATIC WHITE STROKE FOR SELECTED LETTERS
        if (b.__selected && !b.isRemoved) {
            ctx.save();
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'white';
            ctx.beginPath();
            const r = (b.circleRadius || CONFIG.letterSize/2);
            ctx.arc(b.position.x, b.position.y, r + 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        if (b.label === 'letter' && b.letter && b.__flash && !b.isRemoved){
          const f = b.__flash;
          const t = clamp((now - f.start) / f.duration, 0, 1);
          const scale = 1 + (Math.sin(t * Math.PI) * f.maxScale);
          const alpha = 0.9 * (1 - Math.pow(t,0.9));
          const radius = (b.circleRadius || CONFIG.letterSize/2) * scale;
          ctx.globalAlpha = alpha;
          ctx.beginPath();
          ctx.fillStyle = f.color || '#fff59a';
          ctx.arc(b.position.x, b.position.y, radius, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
          const glyph = glyphs[b.letter] || glyphs['A'];
          const size = CONFIG.letterSize * scale;
          ctx.drawImage(glyph, b.position.x - size/2, b.position.y - size/2, size, size);
        }
      } catch(e){}
    }

    // particles
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      const age = performance.now() - p.start;
      const lifePct = 1 - age / p.life;
      if (lifePct <= 0){ particles.splice(i,1); continue; }
      p.vy += 0.06;
      p.x += p.vx; p.y += p.vy;
      ctx.globalAlpha = Math.max(0, lifePct);
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }

    // floating statuses (sanitized short text)
    for (let i = floatingStatuses.length - 1; i >= 0; i--){
      const s = floatingStatuses[i];
      const t = (now - s.start) / s.duration;
      if (t >= 1){ floatingStatuses.splice(i,1); continue; }
      const yy = s.y - (t * 40);
      const alpha = 1 - t;
      ctx.globalAlpha = alpha;
      ctx.font = `700 ${s.size}px Inter, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillText(s.text, s.x + 1, yy + 1);
      ctx.fillStyle = s.color;
      ctx.fillText(s.text, s.x, yy);
    }
    ctx.globalAlpha = 1;
  } catch (e) {
    console.error('drawLetters error', e);
  }
}

/* ---------------------- POINTER / DRAGGING & SELECTION (SHIFT) ---------------------- */
function worldPointFromEvent(evt){
  const rect = playWrap.getBoundingClientRect();
  const x = (evt.clientX || (evt.touches && evt.touches[0].clientX) || 0) - rect.left;
  const y = (evt.clientY || (evt.touches && evt.touches[0].clientY) || 0) - rect.top;
  return { x, y };
}

// clamp a desired position so a circular body stays inside the play area
function clampPositionToPlayWrap(x, y, radius){
  const w = playWrap.clientWidth || render.options.width;
  const h = playWrap.clientHeight || render.options.height;
  const minX = Math.max(radius, 0);
  const maxX = Math.max(radius, w - radius);
  const minY = Math.max(radius, 0);
  const maxY = Math.max(radius, h - radius);
  return { x: clamp(x, minX, maxX), y: clamp(y, minY, maxY) };
}
function getBodyRadius(b){ return (b && b.circleRadius) || (CONFIG.letterSize/2); }

// Long-press & connect-mode for mobile
let longPressTimer = null;
let longPressThreshold = 280; // ms
let touchMoveThreshold = 8;    // px - movement allowed while long-pressing
let touchStartPos = null;
let longPressTriggered = false;
let potentialDragBody = null; // on touch, remember initial body to start dragging if user moves

function onPointerDown(e){
  const p = worldPointFromEvent(e);
  pointer.isDown = true; pointer.x = p.x; pointer.y = p.y;
  const found = Matter.Query.point(Matter.Composite.allBodies(world), p);
  if (found.length){
    let body = null;
    for (let i=found.length-1;i>=0;i--){ if (found[i].label==='letter'){ body = found[i]; break; } }
    const isTouch = (e.pointerType === 'touch' || e.pointerType === 'pen');

    // store start pos for long-press detection
    touchStartPos = { x: p.x, y: p.y };
    longPressTriggered = false;
    if (longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }

    // Priority rules (updated):
    // - If effective connect mode (pinned OR Shift) -> selection
    // - If touch and not connect -> start long-press to select or prepare for drag
    // - If non-touch and not connect -> drag
    if (body){
      const eff = effectiveConnectModeForEvent(e);
      if (eff){
        startSelection(body);
        return;
      }
      if (isTouch){
        // on touch: remember the touched body — if user holds -> selection, if user moves -> drag
        potentialDragBody = body;
        longPressTimer = setTimeout(() => {
          longPressTriggered = true;
          // only start selection if still appropriate
          startSelection(body);
          longPressTimer = null;
          potentialDragBody = null;
        }, longPressThreshold);
        return;
      } else {
        // non-touch: normal dragging
        startDraggingBody(body, p);
        return;
      }
    } else {
      // no body found: still prepare long press cancellation state for touch
      if ((e.pointerType === 'touch' || e.pointerType === 'pen')){
        longPressTimer = setTimeout(() => { longPressTriggered = true; longPressTimer = null; }, longPressThreshold);
      }
    }
  } else {
    // no bodies: still set touch timers if touch
    if ((e.pointerType === 'touch' || e.pointerType === 'pen')){
      touchStartPos = { x: p.x, y: p.y };
      longPressTriggered = false;
      if (longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }
      longPressTimer = setTimeout(() => { longPressTriggered = true; longPressTimer = null; }, longPressThreshold);
    }
  }
}

function onPointerMove(e){
  if (!pointer.isDown) return;
  const p = worldPointFromEvent(e);
  pointer.x = p.x; pointer.y = p.y;
  const isTouch = (e.pointerType === 'touch' || e.pointerType === 'pen');

  // If we are waiting for a long-press, cancel it if user moved too far (interpreted as drag)
  if (longPressTimer && touchStartPos){
    const dx = p.x - touchStartPos.x;
    const dy = p.y - touchStartPos.y;
    if ((dx*dx + dy*dy) > (touchMoveThreshold * touchMoveThreshold)){
      clearTimeout(longPressTimer);
      longPressTimer = null;
      // if user touched a body and moved, start dragging that body
      if (potentialDragBody && !selectionActive && !dragging.body){
        startDraggingBody(potentialDragBody, p);
        potentialDragBody = null;
      }
    }
  }

  if (selectionActive){
    const found = Matter.Query.point(Matter.Composite.allBodies(world), p);
    if (found.length){
      let over = null;
      for (let i=found.length-1;i>=0;i--){ if (found[i].label==='letter'){ over = found[i]; break; } }
      if (over && !over.isRemoved && !selection.bodies.includes(over)){
        if (selection.bodies.length === 0){
          appendToSelection(over);
        } else {
          const last = selection.lastBody;
          const neigh = adjacency.get(last);
          if (neigh && neigh.has(over)){
            appendToSelection(over);
          }
        }
      }
    }
    return;
  }

  if (dragging.body){
    const b = dragging.body;
    const radius = getBodyRadius(b);
    const clamped = clampPositionToPlayWrap(p.x, p.y, radius);
    Matter.Body.setPosition(b, { x: clamped.x, y: clamped.y });
    Matter.Body.setAngle(b, 0);
    dragging.lastPos = { x: clamped.x, y: clamped.y };
    dragging.lastTime = performance.now();
  } else {
    // If a long-press triggered but we didn't have a body initially, start selection if now over a letter
    if (longPressTriggered && !selectionActive){
      const found = Matter.Query.point(Matter.Composite.allBodies(world), p);
      if (found.length){
        let body = null;
        for (let i=found.length-1;i>=0;i--){ if (found[i].label==='letter'){ body = found[i]; break; } }
        if (body) startSelection(body);
      }
    }
  }
}

function onPointerUp(e){
  pointer.isDown = false;
  const p = worldPointFromEvent(e);
  pointer.x = p.x; pointer.y = p.y;

  // clear any pending long-press timer
  if (longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }
  longPressTriggered = false;
  touchStartPos = null;
  potentialDragBody = null;

  if (selectionActive){
    finalizeSelection();
    return;
  }
  if (dragging.body) endDraggingBody();
}

// attach listeners
canvas.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointermove', onPointerMove);
window.addEventListener('pointerup', onPointerUp);

function startDraggingBody(body, p){
  dragging.body = body;
  dragging.lastPos = { x: p.x, y: p.y };
  dragging.lastTime = performance.now();
  // Clamp initial position to ensure body starts inside bounds
  const radius = getBodyRadius(body);
  const clamped = clampPositionToPlayWrap(body.position.x, body.position.y, radius);
  Matter.Body.setPosition(body, { x: clamped.x, y: clamped.y });
  Matter.Body.setStatic(body, true);
  try { Matter.World.remove(world, body); Matter.World.add(world, body); } catch(e){}
}
function endDraggingBody(){
  const body = dragging.body; if (!body) return;
  const now = performance.now();
  const dt = Math.max(1, now - (dragging.lastTime || now));
  const last = dragging.lastPos || { x: body.position.x, y: body.position.y };
  let vx = (pointer.x - last.x) / (dt/1000);
  let vy = (pointer.y - last.y) / (dt/1000);

  // Before releasing, clamp the body's position back inside the play area
  const radius = getBodyRadius(body);
  const clamped = clampPositionToPlayWrap(body.position.x, body.position.y, radius);
  Matter.Body.setPosition(body, { x: clamped.x, y: clamped.y });

  // If the pointer was outside the area (causing a large velocity), damp it so the body doesn't shoot out
  const maxVx = 20, maxVy = 30;
  vx = clamp(vx * 0.2, -maxVx, maxVx);
  vy = clamp(vy * 0.2, -maxVy, maxVy);

  Matter.Body.setStatic(body, false);
  Matter.Body.setVelocity(body, { x: vx, y: vy });
  dragging.body = null; dragging.lastPos = null;
}

/* ---------------------- Selection helpers ---------------------- */
function startSelection(firstBody){
  selectionActive = true;
  selection.bodies = [];
  selection.lastBody = null;
  if (runner) runner.enabled = false;
  appendToSelection(firstBody);
}
function appendToSelection(b){
  if (!b || b.isRemoved) return;
  selection.bodies.push(b);
  selection.lastBody = b;
  b.__flash = { start: performance.now(), duration: 600, color: '#60a5fa', maxScale: 0 };
  b.__selected = true;
}
async function finalizeSelection(){
  selectionActive = false;
  const seq = selection.bodies.map(b => (b.letter||'').toLowerCase()).join('');
  const cx = selection.bodies.reduce((s, b) => s + b.position.x, 0) / Math.max(1, selection.bodies.length || 1);
  const cy = selection.bodies.reduce((s, b) => s + b.position.y, 0) / Math.max(1, selection.bodies.length || 1);
  const clearSelectionVisuals = () => {
    for (const b of selection.bodies){ if (b){ b.__flash = null; b.__selected = false; } }
    selection.bodies = []; selection.lastBody = null;
  };
  if (seq.length >= CONFIG.wordMinLength){
    try {
      const isWord = await dictContainsAsync(seq);
      if (isWord){
        await flashPauseAndRemove(selection.bodies.slice(), seq);
        if (runner) runner.enabled = true;
        clearSelectionVisuals();
        return;
      } else {
        showFloatingStatus('Invalid word', cx, cy, { color: '#ff7b7b', size: 16, duration: 1000 });
        clearSelectionVisuals();
        if (runner) runner.enabled = true;
        return;
      }
    } catch (err){
      console.error('dict lookup error', err);
      showFloatingStatus('Dictionary error', cx, cy, { color: '#ff7b7b', size: 16, duration: 1200 });
      clearSelectionVisuals();
      if (runner) runner.enabled = true;
      return;
    }
  } else {
    showFloatingStatus('Too short', cx, cy, { color: '#ff7b7b', size: 16, duration: 1000 });
    clearSelectionVisuals();
    if (runner) runner.enabled = true;
  }
}

/* ---------------------- (Existing) CLUSTER DETECTION & ANAGRAMS (left in file but not auto-run) ---------------------- */
function getLetterBodies(){ return Matter.Composite.allBodies(world).filter(b => b.label === 'letter' && !b.isRemoved); }
function buildLetterCounts(bodies){ const counts = {}; for (const b of bodies){ const ch = (b.letter || '').toLowerCase(); if (!ch) continue; counts[ch] = (counts[ch]||0) + 1; } return counts; }
function canFormWordFromCounts(word, counts){ const temp = {}; for (const ch of word){ temp[ch] = (temp[ch]||0) + 1; if ((counts[ch]||0) < temp[ch]) return false; } return true; }
function findConnectedSubsetForWord(clusterBodies, word){ return null; }
function processClusterForAnagrams(clusterBodies){ return false; }
function detectClustersAndRemoveWords(){ /* intentionally no-op in SHIFT-mode */ }

/* ---------------------- FLASH + SINGLE FADE LOOP FOR REMOVAL ---------------------- */
function flashPauseAndRemove(bodies, word){
  return new Promise(resolve => {
    if (!bodies || bodies.length === 0){ resolve(false); return; }
    animationPlaying = true;
    if (runner) runner.enabled = false;
    const start = performance.now();
    const duration = CONFIG.flashPauseMs;
    const flashColor = '#fff59a';
    for (const b of bodies){ b.__flash = { start, duration, color: flashColor, maxScale: 0.9 }; }
    setTimeout(()=> {
      for (const b of bodies){ if (b) b.__flash = null; }
      fadeAndRemoveBodies(bodies, word).then(()=> {
        animationPlaying = false;
        if (runner) runner.enabled = true;
        resolve(true);
      });
    }, duration);
  });
}
function fadeAndRemoveBodies(bodies, word){
  return new Promise(resolve => {
    const group = bodies.filter(b => b && !b.isRemoved);
    if (!group.length){ resolve(); return; }
    const len = word.length;
    const points = len * CONFIG.scorePerLetter;
    // Player-formed words count toward both the total score and progression score
    score += points;
    progressScore += points;
    scoreEl.textContent = score;
    if (hudScore) hudScore.textContent = score;
    wordsMatched.unshift({ word: word.toUpperCase(), points });
    if (wordsMatched.length > 12) wordsMatched.pop();
    refreshRecentWords();
    wordsCountEl.textContent = parseInt(wordsCountEl.textContent || '0') + 1; if (mobileWordsCount) mobileWordsCount.textContent = wordsCountEl.textContent;
    let cx = 0, cy = 0;
    for (const b of group){ if (!b) continue; cx += b.position.x; cy += b.position.y; spawnExplosion(b.position.x, b.position.y, 6, '#fff'); }
    cx /= group.length; cy /= group.length;
    showFloatingStatus(`${word.toUpperCase()} +${points}`, cx, cy, { color: '#e6f6ff', size: 18, duration: 1200 });

    // --- COMBO HANDLING: increment streak and apply combo bonus if applicable ---
    handleComboOnMatch(false);

    for (const b of group){ b.isRemoved = true; clearEdgesForBody(b); }
    checkLevelProgress();
    const start = performance.now();
    const dur = CONFIG.fadeDuration;
    function tick(){
      const t = (performance.now() - start) / dur;
      if (t >= 1){
        for (const b of group){ try{ Matter.World.remove(world, b); } catch(e){} lettersOnScreen = Math.max(0, lettersOnScreen - 1); }
        lettersCountEl.textContent = lettersOnScreen; if (mobileLettersCount) mobileLettersCount.textContent = lettersOnScreen;
        resolve();
        return;
      } else { for (const b of group) b.__fadeAlpha = 1 - t; requestAnimationFrame(tick); }
    }
    requestAnimationFrame(tick);
  });
}

/* ---------------------- COMBO SYSTEM ---------------------- */
let comboStreak = 0; // consecutive word matches without hint
let comboExpiresAt = 0; // timestamp in ms when combo expires
let comboTimerIv = null;

function getComboBonusForStreak(n){
  if (n < CONFIG.comboStartThreshold) return 0;
  if (n < CONFIG.comboBonuses.length) return CONFIG.comboBonuses[n];
  return CONFIG.comboMaxBonusFrom7;
}
function getComboDurationForStreak(n){
  if (n < CONFIG.comboStartThreshold) return 0;
  // 3 => base (comboDurationAt3), 4 => -decrease, etc
  const levelIndex = n - CONFIG.comboStartThreshold; // 0 for 3rd
  const dur = CONFIG.comboDurationAt3 - (levelIndex * CONFIG.comboDurationDecreasePerLevel);
  return Math.max(CONFIG.comboDurationMin, dur);
}

function startComboTimer(){
  if (comboTimerIv) clearInterval(comboTimerIv);
  comboTimerIv = setInterval(()=>{
    updateComboBar();
    if (comboExpiresAt && performance.now() >= comboExpiresAt){
      // combo expired
      showFloatingStatus('Combo expired', render.options.width/2, 60, { color:'#ff7b7b', size:14, duration:900 });
      resetCombo();
    }
  }, 120);
}
function stopComboTimer(){ if (comboTimerIv) { clearInterval(comboTimerIv); comboTimerIv = null; } }

function updateComboBar(){
  if (!comboExpiresAt){ comboWrap.style.display = 'none'; comboBarInnerEl.style.width = '0%'; comboTextEl.textContent = 'Combo x0'; return; }
  const remaining = Math.max(0, comboExpiresAt - performance.now());
  const dur = getComboDurationForStreak(comboStreak) * 1000;
  if (dur <= 0){ comboWrap.style.display = 'none'; comboBarInnerEl.style.width = '0%'; return; }
  const pct = clamp((remaining / dur) * 100, 0, 100);
  comboWrap.style.display = 'block';
  comboBarInnerEl.style.width = `${pct}%`;
  comboTextEl.textContent = `Combo x${comboStreak}`;
}

function resetCombo(reason){
  comboStreak = 0;
  comboExpiresAt = 0;
  stopComboTimer();
  updateComboBar();
}

function handleComboOnMatch(wasHintUsed){
  // If a hint was used recently, reset the combo streak
  if (wasHintUsed){ resetCombo('hint'); return; }
  comboStreak += 1;
  // Only apply bonus from the threshold
  const bonus = getComboBonusForStreak(comboStreak);
  if (bonus > 0){
    // apply combo bonus to both total score and progression score
    score += bonus;
    progressScore += bonus;
    scoreEl.textContent = score;
    if (hudScore) hudScore.textContent = score;
    updateLevelUI();
    // show floating and play particles
    showFloatingStatus(`Combo +${bonus}`, render.options.width/2, 80, { color: '#ffd27a', size: 16, duration: 1400 });
    spawnExplosion(render.options.width/2, 80, 12, '#ffd27a');
    // reset combo timer to the duration for this streak
    const durSec = getComboDurationForStreak(comboStreak);
    comboExpiresAt = performance.now() + durSec * 1000;
    startComboTimer();
    updateComboBar();
  } else {
    // below threshold: still increment streak but do not start timer yet
    // if streak reached the threshold exactly, start timer and award
    if (comboStreak === CONFIG.comboStartThreshold){
      const bonus2 = getComboBonusForStreak(comboStreak);
      if (bonus2 > 0){
        score += bonus2;
        progressScore += bonus2;
        scoreEl.textContent = score;
        if (hudScore) hudScore.textContent = score;
        updateLevelUI();
        showFloatingStatus(`Combo +${bonus2}`, render.options.width/2, 80, { color: '#ffd27a', size: 16, duration: 1400 });
        spawnExplosion(render.options.width/2, 80, 12, '#ffd27a');
      }
      const durSec = getComboDurationForStreak(comboStreak);
      comboExpiresAt = performance.now() + durSec * 1000;
      startComboTimer();
      updateComboBar();
    }
  }
}

/* When player requests a hint, that should break combos */
function breakComboDueToHint(){
  if (comboStreak > 0) showFloatingStatus('Combo broken (hint)', render.options.width/2, 90, { color:'#ff7b7b', size:14, duration:1400 });
  resetCombo('hint');
}

/* ---------------------- LEVEL / PROGRESSION ---------------------- */
function computeScoreNeededForLevel(lv){
  const n = Math.max(0, lv - 1);
  const a = CONFIG.levelScoreIncrement;
  const d = CONFIG.levelScoreIncrementGrowth;
  return CONFIG.levelBaseScore + (n * a) + (d * (n * (n - 1) / 2));
}
function checkLevelProgress(){
  updateLevelUI();
  const needed = computeScoreNeededForLevel(level);
  if (progressScore >= needed){
    level += 1;
    progressScore = 0;
    applyLevelUpEffects();
    updateLevelUI();
  }
}
function updateLevelUI(){
  levelNumEl.textContent = String(level);
  if (mobileLevelNum) mobileLevelNum.textContent = String(level);
  const needed = computeScoreNeededForLevel(level);
  const progress = clamp((progressScore) / Math.max(1, needed), 0, 1);
  levelProgressTextEl.textContent = `Progress: ${progressScore}/${needed}`;
  if (mobileLevelProgressText) mobileLevelProgressText.textContent = `Progress: ${progressScore}/${needed}`;
  const pct = Math.round(progress * 100);
  levelBarInnerEl.style.width = `${pct}%`;
  if (mobileLevelBarInner) mobileLevelBarInner.style.width = `${pct}%`;
}
function applyLevelUpEffects(){
  if (level > 1 && ((level - 1) % 2 === 0)){
    CONFIG.maxLetters += 15;
    setTimeout(() => {
      showFloatingStatus(
        `Capacity increased to ${CONFIG.maxLetters}`,
        render.options.width / 2,
        90,
        { color: '#60a5fa', size: 14, duration: 1600 }
      );
    }, 300);
  }
  const letters = getLetterBodies().filter(b => !b.isRemoved);
  const toRemoveCount = Math.floor(letters.length * CONFIG.removeFractionOnLevel);
  if (toRemoveCount > 0){
    const chosen = [];
    const pool = letters.slice();
    for (let i=0;i<toRemoveCount;i++){ if (pool.length === 0) break; const idx = Math.floor(Math.random()*pool.length); chosen.push(pool[idx]); pool.splice(idx,1); }
    const pts = chosen.length * CONFIG.pointsPerRemovedLetter;
    showFloatingStatus(`Level up! Clearing ${chosen.length} letters. +${pts}`, render.options.width/2, 60, { color: '#fff59a', size: 16, duration: 1800 });
    for (const b of chosen){ if (b) spawnExplosion(b.position.x, b.position.y, 8, '#ffd27a'); }

    // suspend async checks until refill completes
    suspendChecksDuringFill = true;
    removeLettersForLevelUp(chosen, pts);

  } else {
    showFloatingStatus(`Level up! +0`, render.options.width/2, 60, { color: '#fff59a', size: 14, duration: 1400 });
  }

  // refill after short delay; resume async checks only when spawnUntilMax finishes
  setTimeout(() => {
    spawnUntilMax().then(() => {
      // refill complete -> allow async checks again (if game still running)
      suspendChecksDuringFill = false;
      if (running) startAsyncGameChecks();
    });
  }, 360);

  updateLevelUI();
}
function removeLettersForLevelUp(bodies, pts){
  if (!bodies || bodies.length === 0) return;
  score += pts;
  scoreEl.textContent = score;
  if (hudScore) hudScore.textContent = score;
  for (const b of bodies){ if (!b || b.isRemoved) continue; b.isRemoved = true; clearEdgesForBody(b); }
  const start = performance.now();
  const dur = 260;
  function tick(){
    const t = (performance.now() - start) / dur;
    if (t >= 1){
      for (const b of bodies){ try{ Matter.World.remove(world, b); } catch(e){} lettersOnScreen = Math.max(0, lettersOnScreen - 1); }
      lettersCountEl.textContent = lettersOnScreen; if (mobileLettersCount) mobileLettersCount.textContent = lettersOnScreen;
      return;
    } else { for (const b of bodies) if (b) b.__fadeAlpha = 1 - t; requestAnimationFrame(tick); }
  }
  requestAnimationFrame(tick);
}

/* ---------------------- GAMEOVER CHECK & HINT SYSTEM ---------------------- */
async function findConnectedWordHint(){
  const bodies = getLetterBodies();
  const visited = new Set();
  const components = [];
  for (const b of bodies){ if (visited.has(b)) continue; const comp = []; const q = [b]; visited.add(b); while (q.length){ const cur = q.pop(); comp.push(cur); const neighs = adjacency.get(cur); if (neighs){ for (const n of neighs){ if (!visited.has(n) && !n.isRemoved){ visited.add(n); q.push(n); } } } } if (comp.length) components.push(comp); }
  for (const comp of components){
    const compSet = new Set(comp);
    comp.sort((a,b)=>a.spawnId - b.spawnId);
    const found = await searchComponentForWord(comp);
    if (found) return found;
  }
  return null;
}

async function searchComponentForWord(comp){
  const maxDepth = CONFIG.hintMaxDepth;
  const startTime = performance.now();
  const timeLimit = CONFIG.hintSearchMillisPerMode;
  let best = null;
  let bestScore = 0;
  let nodesExplored = 0;

  async function dfs(path){
    if (performance.now() - startTime > timeLimit) return;
    if (nodesExplored++ > CONFIG.hintMaxNodes) return;
    const seq = path.map(b=>b.letter.toLowerCase()).join('');
    if (seq.length >= CONFIG.wordMinLength){
      const isWord = await dictContainsAsync(seq);
      if (isWord){
        const score = seq.length;
        if (score > bestScore){ bestScore = score; best = path.slice(); }
      }
    }
    if (seq.length >= maxDepth) return;
    const isPref = await dictIsPrefixAsync(seq);
    if (!isPref) return;
    const last = path[path.length-1];
    const neighs = Array.from(adjacency.get(last) || []).filter(x=>!x.isRemoved && !path.includes(x));
    for (const n of neighs){ await dfs(path.concat(n)); if (performance.now() - startTime > timeLimit) return; if (nodesExplored > CONFIG.hintMaxNodes) return; }
  }

  for (const b of comp){ await dfs([b]); if (performance.now() - startTime > timeLimit) break; if (nodesExplored > CONFIG.hintMaxNodes) break; }
  return best;
}

async function findAnyWordFromBoard(){
  const bodies = getLetterBodies();
  if (!bodies.length) return null;
  const startTime = performance.now();
  const timeLimit = CONFIG.hintSearchMillisPerMode;
  const maxDepth = CONFIG.hintMaxDepth;
  let nodesExplored = 0;
  let best = null;
  let bestScore = 0;

  async function dfs(path, used){
    if (performance.now() - startTime > timeLimit) return;
    if (nodesExplored++ > CONFIG.hintMaxNodes) return;
    const seq = path.map(b=>b.letter.toLowerCase()).join('');
    if (seq.length >= CONFIG.wordMinLength){
      const isWord = await dictContainsAsync(seq);
      if (isWord){
        const score = seq.length;
        if (score > bestScore){ bestScore = score; best = path.slice(); }
      }
    }
    if (seq.length >= maxDepth) return;
    const isPref = await dictIsPrefixAsync(seq);
    if (!isPref) return;
    for (const b of bodies){ if (used.has(b) || b.isRemoved) continue; used.add(b); await dfs(path.concat(b), used); used.delete(b); if (performance.now() - startTime > timeLimit) return; if (nodesExplored > CONFIG.hintMaxNodes) return; }
  }

  for (const b of bodies){ const used = new Set([b]); await dfs([b], used); if (performance.now() - startTime > timeLimit) break; if (nodesExplored > CONFIG.hintMaxNodes) break; }
  return best;
}

async function findHintCandidate(){
  await dictLoadedPromise; // ensure dictionary available
  const connected = await findConnectedWordHint();
  if (connected && connected.length) return connected;
  const any = await findAnyWordFromBoard();
  return any;
}

function applyHintToBodies(bodies){
  for (const b of getLetterBodies()) b.__hint = false;
  if (!bodies || !bodies.length) return;
  for (const b of bodies){ b.__hint = true; }
  setTimeout(()=>{ for (const b of bodies){ if (b) b.__hint = false; } }, CONFIG.hintHighlightMs);
}

/* Public: call when player asks for hint (or when the game wants to auto-check) */
async function provideHint(){
  if (!running) return;
  // Using a hint breaks the combo streak immediately
  breakComboDueToHint();
  const candidate = await findHintCandidate();
  if (candidate){
    applyHintToBodies(candidate);
    const word = candidate.map(b=>b.letter).join('');
    showFloatingStatus(`Hint: ${word}`, render.options.width/2, 60, { color: '#ffd27a', size: 14, duration: 1200 });
    return true;
  } else {
    // no possible word from board -> game over
    showFloatingStatus('No possible words - Game Over', render.options.width/2, 60, { color: '#ff7b7b', size: 14, duration: 1400 });
    endGame();
    return false;
  }
}

// Evaluate whether ANY word is possible (used by game over check)
async function hasAnyPlayableWord(){
  const candidate = await findHintCandidate();
  return !!candidate;
}

/* ---------------------- GAMEOVER CHECK ---------------------- */
// old condition: letter fell off top
function checkGameOverCondition(){
  const bodies = getLetterBodies();
  for (const b of bodies){ const radius = (b.circleRadius || CONFIG.letterSize/2); if (b.position.y - radius < -5) return true; }
  // synchronous check doesn't decide game over; async check will call endGame when needed
  return false;
}

// We'll run periodic asynchronous checks (every 2s) to detect impossible boards
let asyncGameCheckIv = null;
let suspendChecksDuringFill = false; // new flag to prevent premature game-over checks
function startAsyncGameChecks(){
  if (asyncGameCheckIv) clearInterval(asyncGameCheckIv);
  asyncGameCheckIv = setInterval(async ()=>{
    if (!running) return;
    if (suspendChecksDuringFill) return;          // <- don't run checks while suspended
    // If there are very few letters, skip expensive check
    const bodies = getLetterBodies();
    if (!bodies.length) return;
    const possible = await hasAnyPlayableWord();
    if (!possible){
      // end game
      showFloatingStatus('No possible words - Game Over', render.options.width/2, 60, { color: '#ff7b7b', size: 14, duration: 1600 });
      endGame();
    }
  }, 2000);
}
function stopAsyncGameChecks(){ if (asyncGameCheckIv) clearInterval(asyncGameCheckIv); asyncGameCheckIv = null; }

/* ---------------------- UI helpers ---------------------- */
function refreshRecentWords(){
  recentWordsEl.innerHTML = '';
  if (!wordsMatched.length){
    recentWordsEl.innerHTML = '<p class="muted">No words yet.</p>'; return;
  }
  for (const w of wordsMatched){
    const p = document.createElement('p');
    p.style.margin = '6px 0';
    const strong = document.createElement('strong');
    strong.style.color = '#e6f6ff';
    strong.textContent = w.word;
    p.appendChild(strong);
    const span = document.createElement('span');
    span.style.color = 'var(--muted)';
    span.style.marginLeft = '8px';
    span.textContent = `+${w.points}`;
    p.appendChild(span);
    recentWordsEl.appendChild(p);
  }
}

/* ---------------------- GAME CONTROL ---------------------- */
function startGame(){
  if (!engine) initMatter();
  resetWorldForNewGame();
  running = true; gameOver = false;
  score = 0; progressScore = 0;
  scoreEl.textContent = score;
  if (hudScore) hudScore.textContent = score;
  wordsMatched = []; refreshRecentWords();
  lettersOnScreen = 0; lettersCountEl.textContent = 0; if (mobileLettersCount) mobileLettersCount.textContent = 0;
  wordsCountEl.textContent = 0; if (mobileWordsCount) mobileWordsCount.textContent = 0;
  level = 1;
  updateLevelUI();
  startBtn.textContent = 'Restart';
  pauseBtn.textContent = 'Pause';
  fillInitialLetters();
  startTime = performance.now();
  if (elapsedTimer) clearInterval(elapsedTimer);
  elapsedTimer = setInterval(updateTimer, 500);
  startAsyncGameChecks();
  // reset combos on new game
  resetCombo('newgame');
}
function resetWorldForNewGame(){
  if (!world) return;
  const bodies = Matter.Composite.allBodies(world).slice();
  for (const b of bodies){ if (b.label === 'letter'){ try{ Matter.World.remove(world, b); } catch(e){} clearEdgesForBody(b); } }
  adjacency.clear();
  lettersOnScreen = 0; lettersCountEl.textContent = 0; if (mobileLettersCount) mobileLettersCount.textContent = 0;
}
function togglePause(){ if (!running) return; if (runner && runner.enabled){ runner.enabled = false; pauseBtn.textContent = 'Resume'; mobilePauseBtn && (mobilePauseBtn.textContent = 'Resume'); } else { runner.enabled = true; pauseBtn.textContent = 'Pause'; mobilePauseBtn && (mobilePauseBtn.textContent = 'Pause'); } }
function endGame(){ running = false; gameOver = true; startBtn.textContent = 'Restart'; pauseBtn.textContent = 'Pause'; stopAsyncGameChecks(); if (elapsedTimer) clearInterval(elapsedTimer); setTimeout(()=> { showGameOverOverlay(`Score: ${score} Words: ${wordsMatched.length}`); }, 80); }
function showGameOverOverlay(text){
  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.left = '50%';
  overlay.style.top = '50%';
  overlay.style.transform = 'translate(-50%,-50%)';
  overlay.style.padding = '20px';
  overlay.style.background = 'linear-gradient(180deg, rgba(2,6,23,0.92), rgba(2,6,23,0.98))';
  overlay.style.border = '1px solid rgba(255,255,255,0.04)';
  overlay.style.borderRadius = '12px';
  overlay.style.zIndex = 999;
  overlay.style.textAlign = 'center';
  overlay.style.color = '#e6f6ff';
  overlay.innerHTML = `<div style="font-weight:700;font-size:18px;margin-bottom:8px">Game Over</div>                        <div style="color:var(--muted);margin-bottom:14px">${String(text).replace(/\n/g,'<br>')}</div>                        <div style="display:flex;gap:8px;justify-content:center">                          <button id="goRestart" class="btn">Restart</button>                          <button id="goClose" class="ghost">Close</button>                        </div>`;
  playWrap.appendChild(overlay);
  document.getElementById('goRestart').addEventListener('click', ()=>{ playWrap.removeChild(overlay); startGame(); });
  document.getElementById('goClose').addEventListener('click', ()=>{ playWrap.removeChild(overlay); });
}

/* Timer */
function updateTimer(){ if (!startTime) return; const diff = Math.floor((performance.now() - startTime)/1000); const mm = String(Math.floor(diff/60)).padStart(2,'0'); const ss = String(diff%60).padStart(2,'0'); timerEl.textContent = `${mm}:${ss}`; if (hudTimer) hudTimer.textContent = `${mm}:${ss}`; }

/* UI wiring */
startBtn.addEventListener('click', ()=> startGame());
pauseBtn.addEventListener('click', ()=> togglePause());
hintBtn.addEventListener('click', ()=> provideHint());

// wire mobile buttons to same actions where appropriate
if (mobileStartBtn) mobileStartBtn.addEventListener('click', ()=> startBtn.click());
if (mobilePauseBtn) mobilePauseBtn.addEventListener('click', ()=> pauseBtn.click());
if (mobileHintBtn) mobileHintBtn.addEventListener('click', ()=> hintBtn.click());
// mobileMenuBtn will toggle the right panel (off-canvas)
if (mobileMenuBtn) mobileMenuBtn.addEventListener('click', ()=>{ const open = rightPanel.classList.toggle('open'); mobileOverlay.classList.toggle('show', open); if (open) { rightPanel.setAttribute('tabindex','-1'); rightPanel.focus(); } });

// Dictionary worker
const dictWorker = new Worker('./dictWorker.js');
let dictLoaded = false;
let dictLoadedResolve;
const dictLoadedPromise = new Promise(res => dictLoadedResolve = res);
let dictNextId = 1;
const dictPending = new Map();
startBtn.disabled = true; const originalStartText = startBtn.textContent || 'Start'; startBtn.textContent = 'Loading dictionary...';

dictWorker.onmessage = (ev) => {
  const d = ev.data;
  if (d.type === 'progress'){
    startBtn.textContent = `Loading dictionary... (${d.pct || Math.round((d.loaded||0)/1000)}%)`;
  } else if (d.type === 'loaded'){
    dictLoaded = true; dictLoadedResolve(); startBtn.disabled = false; startBtn.textContent = originalStartText; showFloatingStatus(`Dictionary loaded (${d.count} words)`, render ? render.options.width/2 : 200, 40, { color:'#7dd3fc', size:16, duration:1400 });
  } else if (d.type === 'contains' || d.type === 'isPrefix'){
    const resolver = dictPending.get(d.id);
    if (resolver){ resolver(d.result); dictPending.delete(d.id); }
  } else if (d.type === 'error'){
    console.error('dictWorker error:', d.message);
    startBtn.textContent = 'Start (dict load failed)';
    startBtn.disabled = false;
  }
};

dictWorker.postMessage({ type: 'loadUrl', url: './wordlist.txt', estimated: 200000 });

function dictContainsAsync(word){
  return new Promise(resolve => {
    dictLoadedPromise.then(() => { const id = dictNextId++; dictPending.set(id, resolve); dictWorker.postMessage({ type: 'contains', id, word }); });
  });
}
function dictIsPrefixAsync(pref){
  return new Promise(resolve => {
    dictLoadedPromise.then(() => { const id = dictNextId++; dictPending.set(id, resolve); dictWorker.postMessage({ type: 'isPrefix', id, pref }); });
  });
}

/* MOBILE SETUP: auto-enable connect mode on touch devices + one-time hint overlay */
function mobileInit(){
  const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.matchMedia('(pointer:coarse)').matches || window.innerWidth < 800;
  if (isTouch){
    // pin connect mode on for touch devices (same UX as before)
    pinnedConnectMode = true;
    updateConnectToggleUI();
    // hide the toggle to reduce clutter on small screens
    connectToggle.style.display = 'none';
    // tweak the instructions text for mobile
    const note = document.getElementById('controlsNote');
    if (note) note.innerHTML = 'Touch & drag to connect letters (or long-press a letter then slide). Drag without holding to reposition.';

    // show one-time overlay hint (store in localStorage)
    try {
      if (!localStorage.getItem('lr_seen_mobile_hint')){
        showMobileHintOverlay();
        localStorage.setItem('lr_seen_mobile_hint', '1');
      }
    } catch(e){}
  }

  // show mobile-ui and mobile buttons on small screens
  const smallScreen = window.innerWidth <= 980 || (window.matchMedia && window.matchMedia('(pointer:coarse)').matches);
  if (smallScreen){
    mobileUI.style.display = 'block';
    mobileButtons.style.display = 'block';
    // do not show the floating sidebarToggle — we use the in-panel Menu button
    // when mobile, hide floatingHud (we use mobileUI)
    // floatingHud removed from DOM in this variant, so nothing to hide
    // when mobile, keep rightPanel off-canvas
    rightPanel.classList.remove('open');
    mobileOverlay.classList.remove('show');
  } else {
    mobileUI.style.display = 'none';
    mobileButtons.style.display = 'none';
    sidebarToggle.style.display = 'none';
  }
}

function showMobileHintOverlay(){
  const ov = document.createElement('div');
  ov.style.position = 'fixed';
  ov.style.left = '12px';
  ov.style.right = '12px';
  ov.style.top = '12px';
  ov.style.padding = '12px';
  ov.style.zIndex = 9999;
  ov.style.backdropFilter = 'blur(6px)';
  ov.style.borderRadius = '12px';
  ov.style.background = 'linear-gradient(180deg, rgba(2,6,23,0.9), rgba(2,6,23,0.8))';
  ov.style.border = '1px solid rgba(255,255,255,0.04)';
  ov.style.color = '#e6f6ff';
  ov.innerHTML = `<div style="font-weight:700;margin-bottom:8px">Tip: touch controls</div><div style="color:var(--muted);font-size:14px">Long-press a letter then slide across adjacent letters to form a word, or enable Connect Mode. Tap anywhere to dismiss.</div>`;
  ov.addEventListener('pointerup', ()=>{ try{ document.body.removeChild(ov); }catch(e){} });
  document.body.appendChild(ov);
}

/* Off-canvas / sidebar toggle handlers (mobile) */
sidebarToggle.addEventListener('click', ()=>{
  const open = rightPanel.classList.toggle('open');
  mobileOverlay.classList.toggle('show', open);
  if (open) {
    // ensure rightPanel is focusable for a11y
    rightPanel.setAttribute('tabindex','-1');
    rightPanel.focus();
  }
});
mobileOverlay.addEventListener('click', ()=>{
  rightPanel.classList.remove('open');
  mobileOverlay.classList.remove('show');
});

/* init */
function init(){ initMatter(); scoreEl.textContent = '0'; timerEl.textContent = '00:00'; lettersCountEl.textContent = '0'; wordsCountEl.textContent = '0'; wordsMatched = []; refreshRecentWords(); level = 1; progressScore = 0; updateLevelUI(); resetCombo('init'); mobileInit(); updateConnectToggleUI(); }
init();
</script>
</body>
</html>
