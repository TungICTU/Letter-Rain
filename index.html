<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Letter Rain - Fun Physics Word Game</title>
  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <style>
  :root{
    --bg:#071226;
    --card:#071627;
    --muted:#9aa8bf;
    --accent:#7dd3fc;
    --accent-2:#60a5fa;
    --scroll-track: rgba(6,10,18,0.45);
    --scroll-thumb: rgba(125,211,252,0.14);   /* light blue translucent */
    --scroll-thumb-strong: rgba(125,211,252,0.28);
    --scroll-thumb-active: rgba(125,211,252,0.46);
    --scroll-shadow: 0 6px 18px rgba(2,6,23,0.5);
    --scroll-radius: 999px;
    --scroll-size: 12px;    /* vertical scrollbar width */
    --scroll-h-size: 10px;  /* horizontal scrollbar height */
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{ height:100%; margin:0; background:linear-gradient(180deg,#021024 0%,#071226 100%); color:#e6f6ff; display:flex; align-items:center; justify-content:center;} /* prevent child overflow from widening the page on mobile */
  .game-shell{ width:940px; max-width:96vw; display:grid; grid-template-columns:1fr 320px; gap:18px; align-items:start; transition:all .24s ease; min-width: 0; }
  .panel{ background:var(--card); padding:18px; border-radius:12px; box-shadow:0 10px 40px rgba(4,9,20,0.6); border:1px solid rgba(255,255,255,0.03); min-width: 0; }
  .left{ display:flex; align-items:center; justify-content:center; position:relative; padding:18px; flex-direction:column; min-width: 0; }
  #play-wrap{ width:580px; height:660px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); overflow:hidden; position:relative; touch-action:none; }
  canvas { width:100%; height:100%; display:block; touch-action:none; }
  .hint{ position:absolute; left:12px; top:12px; font-size:13px; color:var(--muted); z-index:6; }
  .right{ width:320px;}
  h1{ margin:0; font-size:20px; color:#e6f6ff; }
  .muted{ color:var(--muted); font-size:13px; }
  .stat{ display:flex; justify-content:space-between; align-items:center; background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; margin-top:12px; }
  .big{ font-weight:700; font-size:28px; color:#e6f6ff; }
  .controls{ margin-top:14px; display:flex; gap:10px; }
  button.btn{ background:linear-gradient(180deg,var(--accent),var(--accent-2)); border:none; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; color:#013; }
  button.ghost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); padding:10px 12px; border-radius:10px; cursor:pointer; }
  .ghost.active{ background: linear-gradient(180deg, rgba(125,211,252,0.12), rgba(96,165,250,0.08)); border: 1px solid rgba(125,211,252,0.12); color: #7dd3fc; }
  .words-list{ margin-top:16px; max-height:280px; overflow:auto; padding-right:8px; }
  footer.note{ margin-top:12px; font-size:12px; color:var(--muted); }
  .level-wrap{ margin-top:12px; }
  .level-row{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .level-bar{ margin-top:8px; width:100%; height:12px; background:rgba(255,255,255,0.04); border-radius:8px; overflow:hidden; }
  .level-bar-inner{ height:100%; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); border-radius:8px; transition:width 300ms ease; }
  .level-text{ font-size:13px; color:var(--muted); }

  /* Combo UI - positioned below the play area and non-interactive so it won't block canvas */
  .combo-wrap{ margin-top:12px; width:100%; pointer-events:none; }
  .combo-row{ display:flex; align-items:center; gap:8px; }
  .combo-text{ font-weight:700; color:#ffd27a; font-size:13px; width:110px; pointer-events:none; }
  .combo-bar{ flex:1; height:10px; background:rgba(255,255,255,0.03); border-radius:8px; overflow:hidden; }
  .combo-bar-inner{ height:100%; width:0%; background:linear-gradient(90deg,#ffd27a,#ffb86b); transition:width 120ms linear; pointer-events:none; }

  /* -----------------------------
   Modern rarity tag styles
   Paste into the <style> section
   ----------------------------- */
.rarity-tag {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 10px;
  border-radius: 999px;
  font-weight: 700;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.6px;
  line-height: 1;
  white-space: nowrap;
  border: 1px solid rgba(255,255,255,0.04);
  box-shadow: 0 6px 20px rgba(2,6,23,0.45);
  transition: transform 200ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms, opacity 200ms;
  user-select: none;
  -webkit-font-smoothing:antialiased;
}

/* tiny colored dot to the left */
.rarity-tag::before{
  content: "";
  display:inline-block;
  width:10px;
  height:10px;
  border-radius:50%;
  flex:0 0 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.25), 0 0 10px rgba(0,0,0,0.06) inset;
  transform: translateY(-0.5px);
}

/* per-rarity colors (background subtle, text uses the RARITY_COLORS) */
.rarity-uncommon { color: #7dd3fc; background: linear-gradient(90deg, rgba(125,211,252,0.12), rgba(96,165,250,0.08)); border-color: rgba(125,211,252,0.12); }
.rarity-rare     { color: #a78bfa; background: linear-gradient(90deg, rgba(167,139,250,0.24), rgba(124,58,237,0.06)); border-color: rgba(167,139,250,0.12); }
.rarity-epic     { color: #ffd27a; background: linear-gradient(90deg, rgba(255,210,122,0.36), rgba(255,184,107,0.06)); border-color: rgba(255,210,122,0.12); }
.rarity-legendary{ color: #ff6b6b; background: linear-gradient(90deg, rgba(255,107,107,0.36), rgba(255,80,80,0.06)); border-color: rgba(255,107,107,0.12); }

/* dot color follows text color for visual consistency */
.rarity-uncommon::before  { background: #7dd3fc; box-shadow: 0 6px 18px rgba(125,211,252,0.12); }
.rarity-rare::before      { background: #a78bfa; box-shadow: 0 6px 18px rgba(167,139,250,0.12); }
.rarity-epic::before      { background: #ffd27a; box-shadow: 0 6px 18px rgba(255,210,122,0.12); }
.rarity-legendary::before { background: #ff6b6b; box-shadow: 0 6px 18px rgba(255,107,107,0.12); }

/* compact pills for the recent words list so they don't wrap oddly */
.words-list .rarity-tag { margin-left:8px; font-size:11px; padding:3px 8px; }

.scrollable,
.panel,
.words-list,
.word-list,
#recentWords,
#mobileWordList,
body, html {
  scrollbar-width: thin;                  /* firefox: thin variant */
  scrollbar-color: var(--scroll-thumb) var(--scroll-track); /* firefox thumb / track */
}

.scrollable::-webkit-scrollbar,
.panel::-webkit-scrollbar,
.words-list::-webkit-scrollbar,
.word-list::-webkit-scrollbar,
#recentWords::-webkit-scrollbar,
#mobileWordList::-webkit-scrollbar,
html::-webkit-scrollbar,
body::-webkit-scrollbar {
  width: var(--scroll-size);
  height: var(--scroll-h-size);
}
/* Track (background) */
.scrollable::-webkit-scrollbar-track,
.panel::-webkit-scrollbar-track,
.words-list::-webkit-scrollbar-track,
.word-list::-webkit-scrollbar-track,
#recentWords::-webkit-scrollbar-track,
#mobileWordList::-webkit-scrollbar-track {
  background: var(--scroll-track);
  border-radius: var(--scroll-radius);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
}

/* Thumb (the draggable part) */
.scrollable::-webkit-scrollbar-thumb,
.panel::-webkit-scrollbar-thumb,
.words-list::-webkit-scrollbar-thumb,
.word-list::-webkit-scrollbar-thumb,
#recentWords::-webkit-scrollbar-thumb,
#mobileWordList::-webkit-scrollbar-thumb {
  background: var(--scroll-thumb);
  border-radius: var(--scroll-radius);
  min-height: 28px;            /* ensure comfortable grab size vertically */
  min-width: 28px;             /* ensure comfortable grab size horizontally */
  box-shadow: var(--scroll-shadow);
  border: 2px solid transparent;   /* preserved space for thin visual effect */
  background-clip: padding-box;
  transition: background-color 160ms ease, transform 160ms ease, box-shadow 160ms ease;
}

/* Stronger appearance on hover */
.scrollable::-webkit-scrollbar-thumb:hover,
.panel::-webkit-scrollbar-thumb:hover,
.words-list::-webkit-scrollbar-thumb:hover,
.word-list::-webkit-scrollbar-thumb:hover,
#recentWords::-webkit-scrollbar-thumb:hover,
#mobileWordList::-webkit-scrollbar-thumb:hover {
  background: var(--scroll-thumb-strong);
  transform: scale(1.02);
}

/* Active / dragging */
.scrollable::-webkit-scrollbar-thumb:active,
.panel::-webkit-scrollbar-thumb:active,
.words-list::-webkit-scrollbar-thumb:active,
.word-list::-webkit-scrollbar-thumb:active,
#recentWords::-webkit-scrollbar-thumb:active,
#mobileWordList::-webkit-scrollbar-thumb:active {
  background: var(--scroll-thumb-active);
  transform: scale(1.04);
  box-shadow: 0 10px 30px rgba(2,6,23,0.6);
}

/* Corner (when both scrollbars present) */
.scrollable::-webkit-scrollbar-corner,
.panel::-webkit-scrollbar-corner {
  background: transparent;
}

/* ---------- Horizontal scroller thin / pill-style for word-list ---------- */
/* Make the horizontal word-list scrollbar a low-profile pill and keep it subtle */
.word-list::-webkit-scrollbar,
#mobileWordList::-webkit-scrollbar {
  height: 8px;                 /* shorter horizontal bar */
}
.word-list::-webkit-scrollbar-thumb,
#mobileWordList::-webkit-scrollbar-thumb {
  border-radius: 999px;
  min-height: 8px;
  min-width: 44px;             /* ensure visible grab handle */
  background: linear-gradient(90deg, rgba(125,211,252,0.18), rgba(167,139,250,0.12));
  box-shadow: none;
}

/* Firefox horizontal thin styling (best-effort) */
.word-list, #mobileWordList {
  scrollbar-width: thin;
  scrollbar-color: var(--scroll-thumb) var(--scroll-track);
}

/* ---------- Accessibility: focus-visible outline for keyboard users ---------- */
.scrollable:focus,
.panel:focus,
.words-list:focus,
.word-list:focus,
#recentWords:focus,
#mobileWordList:focus {
  outline: 2px solid rgba(125,211,252,0.18);
  outline-offset: 2px;
  border-radius: 8px;
}

  /* Mobile-friendly tweaks */
  @media (max-width:980px){
    /* Prevent mobile layouts from growing wider than the viewport */
    html, body { overflow-x: hidden; }

    .game-shell{ grid-template-columns:1fr; gap:12px; padding:12px; width:100%; max-width:100vw; }
    .right{ width:88vw; max-width:420px; position:fixed; right:12px; top:88px; bottom:12px; transform:translateY(20px) translateX(120%); transition:transform .28s cubic-bezier(.2,.9,.2,1); z-index:9998; box-shadow:0 20px 60px rgba(2,6,23,0.8); display:block; }
    .right.open{ transform: translateX(0) translateY(0); }
    /* overlay that will dim when panel open */
    .mobile-overlay{ position:fixed; left:0; right:0; top:0; bottom:0; background:rgba(0,0,0,0.36); z-index:9997; display:none; }
    .mobile-overlay.show{ display:block; }

    #play-wrap{ width:100%; max-width: 100%; height:42vh; min-height:280px; border-radius:14px; padding:6px; }
    .controls{ flex-wrap:wrap; gap:8px; }
    .controls button{ flex:1 1 48%; min-width:120px; }
    button.btn{ padding:8px 12px; font-size:14px; border-radius:10px; }
    button.ghost{ padding:8px 12px; font-size:14px; border-radius:10px; }
    button.btn,
    button.ghost{
      -webkit-user-select: none;  /* Safari/Chrome on iOS/Android */
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;     /* iOS long-press callout */
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation; 
    }
    .muted{ font-size:14px; }
    .level-text{ font-size:13px; }
    .words-list{ max-height:180px; }
    footer.note{ font-size:13px; }
    /* move combo UI slightly larger for touch readability */
    .combo-text{ font-size:14px; }
    .combo-bar{ height:12px; }

    /* Mobile-specific UI container */
    .mobile-ui{ display:block; width:100%; margin-bottom:10px; min-width: 0; }
    .mobile-ui * {
      -webkit-user-select: none;  /* Safari/Chrome on iOS/Android */
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;     /* iOS long-press callout */
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;      /* allow normal taps & scrolling gestures but avoid selection */
    }
    .mobile-toprow{ display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:8px; user-select: none;}
    .mobile-top-card{ background:linear-gradient(180deg, rgba(2,6,23,0.72), rgba(2,6,23,0.6)); padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); display:flex; gap:8px; align-items:center; min-width:60px; }
    .mobile-top-left{ display:flex; gap:8px; align-items:center; }
    .mobile-mid{ margin-bottom:8px; }
    .mobile-level-row{ display:flex; justify-content:space-between; align-items:center; gap:8px; user-select: none;}
    .mobile-progress{ margin-top:6px; }
    .mobile-stats{ display:flex; justify-content:space-between; gap:8px; margin-bottom:8px; user-select: none;}
    /* words list horizontally scrollable */
    .word-list {
      display: flex;
      gap: 8px;
      padding: 8px 6px;
      white-space: nowrap;
      overflow-x: auto;            /* horizontal scrolling allowed */
      overflow-y: hidden;          /* prevent vertical growth */
      -webkit-overflow-scrolling: touch; /* nice momentum scrolling on iOS */
      max-width: 95%;
      box-sizing: border-box;
      /* prevent horizontal overflow from forcing the page to widen */
      min-width: 0;
      max-width: 100%;
      /* allow the list to shrink instead of stretching parent containers */
      flex-shrink: 1;
      /* optional visual hint when content overflows */
      scrollbar-width: thin;       /* Firefox */
    }
    .word-pill{background:var(--glass);padding:6px 10px;border-radius:999px;font-weight:700;font-size:13px;border:1px solid rgba(255,255,255,0.02);flex: 0 0 auto; display: inline-block; white-space: nowrap; max-width: 80vw; overflow: hidden; text-overflow: ellipsis;}
    /* Mobile: make word-pill reflect rarity colors (paste into your <style>, inside the mobile media query) */
    .word-pill.rarity-uncommon {
      color: #7dd3fc;
      background: linear-gradient(90deg, rgba(125,211,252,0.12), rgba(96,165,250,0.08));
      border: 1px solid rgba(125,211,252,0.12);
      box-shadow: 0 6px 18px rgba(125,211,252,0.06);
    }
    .word-pill.rarity-rare {
      color: #a78bfa;
      background: linear-gradient(90deg, rgba(167,139,250,0.24), rgba(124,58,237,0.06));
      border: 1px solid rgba(167,139,250,0.12);
      box-shadow: 0 6px 18px rgba(167,139,250,0.06);
    }
    .word-pill.rarity-epic {
      color: #ffd27a;
      background: linear-gradient(90deg, rgba(255,210,122,0.36), rgba(255,184,107,0.06));
      border: 1px solid rgba(255,210,122,0.12);
      box-shadow: 0 6px 18px rgba(255,210,122,0.06);
    }
    .word-pill.rarity-legendary {
      color: #ff6b6b;
      background: linear-gradient(90deg, rgba(255,107,107,0.36), rgba(255,80,80,0.06));
      border: 1px solid rgba(255,107,107,0.12);
      box-shadow: 0 6px 18px rgba(255,107,107,0.06);
    }

    /* keep muted pills readable */
    .word-pill.muted {
      color: var(--muted);
      background: transparent;
      border: 1px solid rgba(255,255,255,0.02);
      box-shadow: none;
    }

    /* small polish for touch */
    .word-pill {
      transition: transform 140ms ease, box-shadow 160ms ease, opacity 120ms;
      -webkit-font-smoothing: antialiased;
    }
    .word-pill:active { transform: translateY(1px) scale(0.995); }

    
    /* Floating HUD hidden when mobile-ui is shown */
    #floatingHud{ display:none !important; }

    /* Floating HUD on mobile removed in favor of mobile-ui */
    .hud-card{ display:none; }
    .sidebar-toggle{ display:block; position:fixed; right:12px; top:12px; z-index:10000; border-radius:10px; padding:10px 12px; border:none; background:linear-gradient(180deg,var(--accent),var(--accent-2)); color:#013; font-weight:700; box-shadow:0 8px 30px rgba(2,6,23,0.6); }
  }

  /* Larger devices: increase hit target slightly */
  @media (min-width:981px){
    button.btn{ padding:12px 16px; }
  }

  /* small polish for readability of recent words list */
  .words-list p{ margin:6px 0; line-height:1.2; }
  </style>
</head>
<body>
  <!-- Mobile overlay (for off-canvas right panel) -->
  <div id="mobileOverlay" class="mobile-overlay" tabindex="-1" aria-hidden="true"></div>

  <div class="game-shell" id="gameShell">
    <div class="panel left">
      <!-- MOBILE UI: visible only on small screens -->
      <div class="mobile-ui" id="mobileUI" style="display:none;">
        <div class="mobile-toprow">
          <div class="mobile-top-left">
            <div class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Score</div><div id="hudScore" style="font-weight:700;margin-left:6px;">0</div></div>
            <div class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Time</div><div id="hudTimer" style="font-weight:700;margin-left:6px;">00:00</div></div>
          </div>
          <!-- menu button uses existing sidebarToggle for consistency -->
          <div><button id="mobileMenuBtn" class="sidebar-toggle" style="padding:8px 10px;">Menu</button></div>
        </div>

        <div class="mobile-mid">
          <div class="mobile-level-row">
            <div style="font-weight:700">Level <span id="mobileLevelNum">1</span></div>
            <div class="level-text" id="mobileLevelProgressText">Progress: 0/100</div>
          </div>
          <div class="level-bar mobile-progress" aria-hidden="true"><div id="mobileLevelBarInner" class="level-bar-inner"></div></div>
        </div>

        <div class="mobile-stats">
          <div style="min-width:40%;" class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Words</div><div id="mobileWordsCount" style="font-weight:700;margin-left:6px;">0</div></div>
          <div style="min-width:40%;" class="mobile-top-card"><div style="font-size:12px;color:var(--muted);">Letters</div><div id="mobileLettersCount" style="font-weight:700;margin-left:6px;">0</div></div>
        </div>

        <!-- word list (horizontal) -->
          <div style="margin-top:6px">
          <div id="mobileWordList" class="word-list" aria-live="polite" style="overflow-x:auto; max-width:100%; box-sizing:border-box; -webkit-overflow-scrolling:touch; min-width:0;">
          <div class="word-pill muted">No words yet</div>
          </div>
          </div>
      </div>

      <div id="play-wrap" aria-label="game area">
        <canvas id="gameCanvas"></canvas>
      </div>

      <!-- combo bar placed below the play-wrap (non-interactive so it won't block gameplay) -->
      <div class="combo-wrap" id="comboWrap" style="display:none;" aria-hidden="true">
        <div class="combo-row">
          <div class="combo-text" id="comboText">Combo x0</div>
          <div class="combo-bar" aria-hidden="true"><div id="comboBarInner" class="combo-bar-inner"></div></div>
        </div>
      </div>

      <!-- MOBILE BUTTONS (duplicates that call same actions) -->
      <div id="mobileButtons" style="display:none;margin-top:10px;gap:8px;user-select:none;">
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button id="mobileStartBtn" class="btn">Start</button>
          <button id="mobilePauseBtn" class="ghost">Pause</button>
          <button id="mobileHintBtn" class="ghost">Hint</button>
          <button id="mobileConnectToggle" class="ghost" aria-pressed="false">Connect Mode</button>
        </div>
      </div>

    </div>

     <div class="panel right" id="rightPanel" role="region" aria-label="Game controls">
      <h1>Letter Rain - Connected Touch Anagrams</h1>
      <div class="muted" id="controlsNote">Hold [<strong>Shift</strong> + left-click] and drag to connect the letters. Release to submit the sequence as a word.</div>

      <div class="stat" style="margin-top:16px;">
        <div>
          <div style="font-size:12px;color:var(--muted)">Score</div>
          <div id="score" class="big">0</div>
        </div>
        <div style="text-align:right;">
          <div style="font-size:12px;color:var(--muted)">Time</div>
          <div id="timer" class="big">00:00</div>
        </div>
      </div>

      <div class="controls">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="ghost">Pause</button>
        <button id="hintBtn" class="ghost">Hint</button>
        <!-- Connect mode toggle for mobile -->
        <button id="connectToggle" class="ghost" aria-pressed="false">Connect Mode</button>
      </div>

      <div class="level-wrap">
        <div class="level-row">
          <div style="font-weight:700">Level <span id="levelNum">1</span></div>
          <div class="level-text" id="levelProgressText">Progress: 0/100</div>
        </div>
        <div class="level-bar" aria-hidden="true">
          <div id="levelBarInner" class="level-bar-inner"></div>
        </div>
      </div>

      <div style="display:flex;gap:10px;margin-top:12px;flex-wrap:wrap;">
        <div style="flex:1;min-width:120px;">
          <div style="font-size:12px;color:var(--muted)">Words matched</div>
          <div id="wordsCount" style="font-weight:700">0</div>
        </div>
        <div style="flex:1;min-width:120px;text-align:right;">
          <div style="font-size:12px;color:var(--muted)">Letters remaning</div>
          <div id="lettersCount" style="font-weight:700">0</div>
        </div>
      </div>

      <div class="words-list" id="recentWords"><p class="muted">No words yet.</p></div>

      <footer class="note">Connect letters and earn as much points as you can before you ran out of words to match!</footer>
    </div>
  </div>
 <script>

const CONFIG = {
  letterSpawnInterval: 50, // not used for continuous spawning anymore
  maxLetters: 30,
  initialFillCount: 30,
  fillBurstInterval: 22,
  letterSize: 45,
  gravity: 0.5,
  wordMinLength: 2,
  scorePerLetter: 10,
  spawnHorizontalPadding: 30,
  fadeDuration: 300,
  detectEveryMs: 100,
  flashPauseMs: 520,
  levelBaseScore: 100,
  levelScoreIncrement: 50,
  levelScoreIncrementGrowth: 10,
  spawnDecreasePerLevel: 120,
  minSpawnInterval: 50,
  removeFractionOnLevel: 0.50,
  pointsPerRemovedLetter: 5,
  maxParticles: 600,
  // HINT config
  hintMaxDepth: 8,
  hintMaxNodes: 20000,
  hintSearchMillisPerMode: 300, // ms per search pass
  hintHighlightMs: 4200,
  // COMBO config
  comboStartThreshold: 3, // matches required to start giving combo bonus
  comboBonuses: [0,0,0,10,20,30,40], // index by streak count (0..6), 7+ -> 50
  comboMaxBonusFrom7: 50,
  comboDurationAt3: 30, // seconds at 3rd
  comboDurationDecreasePerLevel: 5, // each level up
  comboDurationMin: 10, // minimum seconds from 7th
};

const RARITY_PERCENTILES = { uncommon: 0.60, rare: 0.80, epic: 0.90, legendary: 0.97 };
const RARITY_BONUS = { uncommon: 10, rare: 20, epic: 30, legendary: 50 };
const RARITY_COLORS = { common: '#e6e9ee', uncommon: '#7dd3fc', rare: '#a78bfa', epic: '#ffd27a', legendary: '#ff6b6b' };

const STORAGE_KEY = 'game_rarity_v1';
const MAX_LOCALSTORAGE_BYTES = 3 * 1024 * 1024; // 3MB guard

let rarityMap = null;       // word -> { score, bucket, rankPct }
let rarityThresholds = {};

function quantile(sortedArr, q){
  if (!sortedArr.length) return 0;
  const pos = (sortedArr.length - 1) * q;
  const lo = Math.floor(pos), hi = Math.ceil(pos);
  if (lo === hi) return sortedArr[lo];
  return sortedArr[lo] * (hi - pos) + sortedArr[hi] * (pos - lo);
}

function buildRarityFromWordlistNgramsSync(words, n = 3){
  // words: array of lowercase words
  const ngramCounts = Object.create(null);
  const add = ng => ngramCounts[ng] = (ngramCounts[ng] || 0) + 1;
  for (const w of words){
    const padded = ` ${w} `;
    for (let i = 0; i <= padded.length - n; i++) add(padded.slice(i, i + n));
  }
  const rarityScores = new Array(words.length);
  for (let i = 0; i < words.length; i++){
    const w = words[i];
    const padded = ` ${w} `;
    let sum = 0, count = 0;
    for (let j = 0; j <= padded.length - n; j++){
      const ng = padded.slice(j, j + n);
      sum += (ngramCounts[ng] || 0);
      count++;
    }
    const avg = (count ? sum / count : 0);
    // invert: smaller avg => rarer
    const score = 1 / (avg + 1e-9);
    rarityScores[i] = score;
  }
  // compute thresholds
  const sortedScores = rarityScores.slice().sort((a,b)=>a-b);
  rarityThresholds.uncommon = quantile(sortedScores, RARITY_PERCENTILES.uncommon);
  rarityThresholds.rare     = quantile(sortedScores, RARITY_PERCENTILES.rare);
  rarityThresholds.epic     = quantile(sortedScores, RARITY_PERCENTILES.epic);
  rarityThresholds.legendary= quantile(sortedScores, RARITY_PERCENTILES.legendary);

  // assign to map
  const map = Object.create(null);
  for (let i = 0; i < words.length; i++){
    const w = words[i];
    const s = rarityScores[i];
    let bucket = 'common';
    if (s >= rarityThresholds.legendary) bucket = 'legendary';
    else if (s >= rarityThresholds.epic) bucket = 'epic';
    else if (s >= rarityThresholds.rare) bucket = 'rare';
    else if (s >= rarityThresholds.uncommon) bucket = 'uncommon';
    map[w] = { score: s, bucket };
  }
  return map;
}

function computeRarity(word){
  if (!word) return 'common';
  const w = String(word).toLowerCase();
  if (rarityMap && rarityMap[w]) return rarityMap[w].bucket;
  // fallback length heuristic
  if (w.length <= 3) return 'common';
  if (w.length === 4) return 'uncommon';
  if (w.length === 5) return 'rare';
  if (w.length === 6) return 'epic';
  return 'legendary';
}

function bytesForString(str){
  return new Blob([str]).size;
}
function tryLoadFromStorage(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    const parsed = JSON.parse(raw);
    if (!parsed || !parsed.mapVersion || !parsed.map) return false;
    rarityMap = parsed.map;
    rarityThresholds = parsed.thresholds || {};
    console.log('Rarity: loaded from cache');
    return true;
  } catch(e){ console.warn('Rarity cache load failed', e); return false; }
}
function trySaveToStorage(mapObj){
  try{
    const payload = { mapVersion: 1, map: mapObj, thresholds: rarityThresholds };
    const s = JSON.stringify(payload);
    if (bytesForString(s) > MAX_LOCALSTORAGE_BYTES){ console.warn('Rarity map too large to cache (~' + bytesForString(s) + ' bytes)'); return false; }
    localStorage.setItem(STORAGE_KEY, s);
    console.log('Rarity: cached to localStorage');
    return true;
  } catch(e){ console.warn('Rarity cache save failed', e); return false; }
}

async function initRarityFromWordlist(path = './wordlist.txt'){
  // Attempt to use cache first
  if (tryLoadFromStorage()) return true;

  try{
    const resp = await fetch(path);
    if (!resp.ok) throw new Error('fetch failed');
    const txt = await resp.text();
    const words = txt.split(/\r?\n/).map(w=>w.trim().toLowerCase()).filter(Boolean);
    if (!words.length) throw new Error('empty wordlist');

    // Build map (synchronous CPU work) - warn for very large lists
    if (words.length > 200000) console.warn('Large wordlist detected (' + words.length + ' words) — building rarity map may take a few seconds in the browser.');

    const map = buildRarityFromWordlistNgramsSync(words, 3);
    // Save only non-common entries to keep map lighter (optional): keep all to preserve accuracy
    // To reduce size, we can drop 'common' entries
    const compact = Object.create(null);
    for (const w of words){
      const entry = map[w];
      if (!entry) continue;
      // store all buckets — you can change to 'if (entry.bucket !== "common")' to make smaller
      compact[w] = entry;
    }
    rarityMap = compact;
    trySaveToStorage(compact);
    console.log('Rarity: built from wordlist (n-gram proxy)');
    return true;
  } catch(e){
    console.warn('initRarityFromWordlist failed:', e);
    return false;
  }
}

// Kick off initialization but do not block game load. When ready, computeRarity() will use it.
(function(){
  // Start init asynchronously
  setTimeout(()=>{

    /* initRarityFromWordlist call disabled in JSON-only patch */
  });
})();

window.__gameRarity = {
  getMap: ()=>rarityMap,
  getThresholds: ()=>rarityThresholds,
  computeRarity
};

// Rarity label formatting
function rarityLabel(name){ return (name||'').toUpperCase(); }

const DICTIONARY_ARRAY = [ ];

class TrieNode { constructor(){ this.children = Object.create(null); this.isWord = false; } }
class Trie { constructor(){ this.root = new TrieNode(); } insert(word){ let node = this.root; for (let i=0;i<word.length;i++){ const ch = word[i]; if (!node.children[ch]) node.children[ch] = new TrieNode(); node = node.children[ch]; } node.isWord = true; } contains(word){ let node = this.root; for (let i=0;i<word.length;i++){ const ch = word[i]; node = node.children[ch]; if (!node) return false; } return !!node.isWord; } isPrefix(pref){ let node = this.root; for (let i=0;i<pref.length;i++){ const ch = pref[i]; node = node.children[ch]; if (!node) return false; } return true; } }
const trie = new Trie(); (function buildTrieFromArray(){ if (Array.isArray(DICTIONARY_ARRAY) && DICTIONARY_ARRAY.length){ for (let i = 0; i < DICTIONARY_ARRAY.length; i++){ trie.insert(String(DICTIONARY_ARRAY[i]).toLowerCase()); } try { DICTIONARY_ARRAY.length = 0; } catch(e){} } })();

const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

const playWrap = document.getElementById('play-wrap');
const canvas = document.getElementById('gameCanvas');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const hintBtn = document.getElementById('hintBtn');
const wordsCountEl = document.getElementById('wordsCount');
const lettersCountEl = document.getElementById('lettersCount');
const recentWordsEl = document.getElementById('recentWords');
const levelNumEl = document.getElementById('levelNum');
const levelProgressTextEl = document.getElementById('levelProgressText');
const levelBarInnerEl = document.getElementById('levelBarInner');

// combo UI
const comboWrap = document.getElementById('comboWrap');
const comboTextEl = document.getElementById('comboText');
const comboBarInnerEl = document.getElementById('comboBarInner');

const rightPanel = document.getElementById('rightPanel');
const sidebarToggle = document.getElementById('sidebarToggle');
const mobileOverlay = document.getElementById('mobileOverlay');

// floating/mobile HUD elements
const hudScore = document.getElementById('hudScore');
const hudTimer = document.getElementById('hudTimer');
const mobileUI = document.getElementById('mobileUI');
const mobileLevelNum = document.getElementById('mobileLevelNum');
const mobileLevelProgressText = document.getElementById('mobileLevelProgressText');
const mobileLevelBarInner = document.getElementById('mobileLevelBarInner');
const mobileWordsCount = document.getElementById('mobileWordsCount');
const mobileLettersCount = document.getElementById('mobileLettersCount');
const mobileButtons = document.getElementById('mobileButtons');

const mobileStartBtn = document.getElementById('mobileStartBtn');
const mobilePauseBtn = document.getElementById('mobilePauseBtn');
const mobileHintBtn = document.getElementById('mobileHintBtn');
const mobileMenuBtn = document.getElementById('mobileMenuBtn');
const mobileConnectToggle = document.getElementById('mobileConnectToggle');

// Replaces the old single `connectMode` boolean with pinned + transient states.
const connectToggle = document.getElementById('connectToggle');
let pinnedConnectMode = false;      // toggled by the Connect button
let transientConnectMode = false;   // temporarily true while Shift is held

function effectiveConnectModeForEvent(evt){
  // Use pinned OR transient OR event.shiftKey (useful when key events might not fire for the pointer's context)
  return pinnedConnectMode || transientConnectMode || (!!(evt && evt.shiftKey));
}
function effectiveConnectMode(){
  return pinnedConnectMode || transientConnectMode;
}
function updateConnectToggleUI(){
  const active = effectiveConnectMode();
  connectToggle.classList.toggle('active', active);
  mobileConnectToggle && mobileConnectToggle.classList.toggle('active', active);
  // aria-pressed represents the pinned state (true if pinned on)
  connectToggle.setAttribute('aria-pressed', String(pinnedConnectMode));
  if (mobileConnectToggle) mobileConnectToggle.setAttribute('aria-pressed', String(pinnedConnectMode));
  connectToggle.textContent = active ? 'Connect: On' : 'Connect Mode';
  if (mobileConnectToggle) mobileConnectToggle.textContent = active ? 'Connect: On' : 'Connect Mode';
}
function togglePinnedConnectMode(){
  pinnedConnectMode = !pinnedConnectMode;
  updateConnectToggleUI();
}
// button toggles pinned state
connectToggle.addEventListener('click', (ev) => {
  togglePinnedConnectMode();
});

// Keyboard listeners to set transientConnectMode when Shift is pressed/released.
// This makes holding Shift behave like "temporarily enable Connect Mode".
window.addEventListener('keydown', (ev) => {
  if (ev.key === 'Shift' && !transientConnectMode){
    transientConnectMode = true;
    updateConnectToggleUI();
  }
});
window.addEventListener('keyup', (ev) => {
  if (ev.key === 'Shift' && transientConnectMode){
    transientConnectMode = false;
    updateConnectToggleUI();
  }
});
// wire mobile connect toggle to the same action
if (mobileConnectToggle) mobileConnectToggle.addEventListener('click', () => { togglePinnedConnectMode(); });

let engine, world, render, runner;
let running = false;
let startTime = null;
let elapsedTimer = null;

/* Scores */
let score = 0;           // total, displayed in UI
let progressScore = 0;   // counts toward level progression only
let wordsMatched = [];
let lettersOnScreen = 0;
let spawnCount = 0;
let gameOver = false;

/* Level state */
let level = 1;

/* Dragging state */
let pointer = { x:0, y:0, isDown:false };
let dragging = { body: null, lastPos: null, lastTime: null };

/* Selection (SHIFT-drag) state */
let selectionActive = false;
let selection = { bodies: [], lastBody: null };

/* Animation flag */
let animationPlaying = false;

/* Adjacency graph: body -> Set(neighbors) */
const adjacency = new Map();

/* Glyph cache for A-Z (offscreen canvases) */
const glyphs = {};
function createGlyph(letter){
  const size = CONFIG.letterSize;
  const oc = document.createElement('canvas');
  oc.width = size; oc.height = size;
  const ctx = oc.getContext('2d');
  ctx.beginPath();
  ctx.arc(size/2, size/2, size/2 - 1, 0, Math.PI*2);
  ctx.fillStyle = '#0ea5e9';
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.stroke();
  ctx.fillStyle = '#0b1320';
  ctx.font = `bold ${Math.round(size * 0.68)}px Inter, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(letter, size/2, size/2 + 1);
  ctx.fillStyle = '#f8fdff';
  ctx.fillText(letter, size/2 + 0, size/2);
  return oc;
}
(function prepareGlyphs(){
  const A = 'A'.charCodeAt(0);
  for (let i=0;i<26;i++){ const ch = String.fromCharCode(A + i); glyphs[ch] = createGlyph(ch); }
})();

/* Particles & Floating Status */
const particles = [];
const floatingStatuses = [];
function spawnParticle(x,y, color){
  const angle = Math.random() * Math.PI * 2;
  const speed = 0.6 + Math.random() * 3.4;
  const life = 400 + Math.random() * 400;
  particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - 1.2, life, start: performance.now(), color, size: 2 + Math.random()*3 });
  if (particles.length > CONFIG.maxParticles) particles.splice(0, particles.length - CONFIG.maxParticles);
}
function spawnExplosion(x,y,count,color){
  const capped = Math.min(count, 80);
  for (let i=0;i<capped;i++) spawnParticle(x + (Math.random()-0.5)*6, y + (Math.random()-0.5)*6, color || '#fff');
}
function showFloatingStatus(text, x, y, opts = {}){
  let safeText = String(text || '').slice(0, 60);
  const now = performance.now();
  const obj = { text: safeText, x: x || (render ? render.options.width/2 : 200), y: y || (render ? render.options.height/2 : 200), start: now, duration: opts.duration || 1400, color: opts.color || '#e6f6ff', size: opts.size || 18 };
  floatingStatuses.push(obj);
}

function initMatter(){
  if (engine) return;
  engine = Matter.Engine.create();
  world = engine.world;
  world.gravity.y = CONFIG.gravity;
  render = Matter.Render.create({
    canvas: canvas,
    engine: engine,
    options: {
      width: playWrap.clientWidth,
      height: playWrap.clientHeight,
      wireframes: false,
      background: 'transparent',
      pixelRatio: (window.devicePixelRatio || 1),
      showVelocity: false
    }
  });
  runner = Matter.Runner.create();
  Matter.Render.run(render);
  Matter.Runner.run(runner, engine);
  updateBoundaries();
  Matter.Events.on(render, 'afterRender', drawLetters);
  Matter.Events.on(engine, 'collisionStart', handleCollisions);
  Matter.Events.on(engine, 'collisionActive', handleCollisions);
  Matter.Events.on(engine, 'collisionEnd', handleCollisionEnd);
  // --- safety: teleport letters that get thrown out of bounds back into the play area ---
Matter.Events.on(engine, 'beforeUpdate', function(){
  try {
    const w = playWrap.clientWidth || (render && render.options.width) || 0;
    const h = playWrap.clientHeight || (render && render.options.height) || 0;
    if (!w || !h) return;

    const bodies = getLetterBodies(); // uses existing helper that returns only letter bodies
    for (const b of bodies){
      if (!b || b.isRemoved) continue;
      // don't interfere with the body currently being dragged by the user
      if (dragging.body === b) continue;

      const r = getBodyRadius(b);
      // define "out of bounds" thresholds (generous so small overlaps won't trigger)
      const tooLeft   = b.position.x < -r * 1.5;
      const tooRight  = b.position.x > w + r * 1.5;
      const tooTop    = b.position.y < -r * 1.5;
      const tooBottom = b.position.y > h + r * 4; // allow some slack below bottom before teleporting

      if (tooLeft || tooRight || tooTop || tooBottom){
        // Choose a safe X inside the play area (keep near current X if reasonable)
        const safeMinX = CONFIG.spawnHorizontalPadding + r;
        const safeMaxX = Math.max(safeMinX, w - CONFIG.spawnHorizontalPadding - r);
        let newX = clamp(Math.round(b.position.x), safeMinX, safeMaxX);
        if (newX < safeMinX || newX > safeMaxX) newX = randInt(safeMinX, safeMaxX);

        // Place it near the top so it 'falls' naturally
        const newY = -r - 12;

        // Teleport + reset rotation/velocities and let it fall
        Matter.Body.setPosition(b, { x: newX, y: newY });
        Matter.Body.setAngle(b, 0);
        Matter.Body.setAngularVelocity(b, 0);
        Matter.Body.setVelocity(b, { x: 0, y: 1 + Math.random() * 1.5 });
        Matter.Body.setStatic(b, false);
        Matter.Sleeping.set(b, false);

        // Re-add to the world to help the engine resolve any stale contacts (safe no-op if already present)
        try { Matter.World.remove(world, b); Matter.World.add(world, b); } catch (err) { /* ignore */ }
      }
    }
  } catch (err) {
    console.warn('bounds-check error', err);
  }
});

  window.addEventListener('resize', updateBoundaries);
}

/* Boundaries */
let walls = [];
function updateBoundaries(){
  if (!playWrap || !render) return;
  const w = playWrap.clientWidth, h = playWrap.clientHeight;
  for (const b of walls) try{ Matter.World.remove(world, b); } catch(e){}
  walls = [];
  const t = 60;
  const left = Matter.Bodies.rectangle(-t/2, h/2, t, h, { isStatic:true, render:{visible:false} });
  const right = Matter.Bodies.rectangle(w + t/2, h/2, t, h, { isStatic:true, render:{visible:false} });
  const bottom = Matter.Bodies.rectangle(w/2, h + t/2, w + t*2, t, { isStatic:true, render:{visible:false} });
  walls.push(left, right, bottom);
  Matter.World.add(world, walls);

  // handle HiDPI canvas sizing
  const pr = render.options.pixelRatio || 1;
  render.canvas.style.width = w + 'px';
  render.canvas.style.height = h + 'px';
  render.canvas.width = Math.round(w * pr);
  render.canvas.height = Math.round(h * pr);

  // ensure drawing is in CSS pixels (scale context to pixel ratio)
  const ctx = render.context;
  ctx.setTransform(pr, 0, 0, pr, 0, 0);

  render.options.width = w;
  render.options.height = h;
}

/* Collision event handlers to update adjacency */
function ensureAdjEntry(b){ if (!adjacency.has(b)) adjacency.set(b, new Set()); }
function addEdge(a,b){ ensureAdjEntry(a); ensureAdjEntry(b); adjacency.get(a).add(b); adjacency.get(b).add(a); }
function removeEdge(a,b){ if (adjacency.has(a)) adjacency.get(a).delete(b); if (adjacency.has(b)) adjacency.get(b).delete(a); }
function clearEdgesForBody(b){ const neighbors = adjacency.get(b); if (!neighbors) return; for (const other of Array.from(neighbors)){ if (adjacency.has(other)) adjacency.get(other).delete(b); } adjacency.delete(b); }
function handleCollisions(ev){ for (const pair of ev.pairs){ const a = pair.bodyA, b = pair.bodyB; if (a.label === 'letter' && b.label === 'letter' && !a.isRemoved && !b.isRemoved){ addEdge(a,b); } } }
function handleCollisionEnd(ev){ for (const pair of ev.pairs){ const a = pair.bodyA, b = pair.bodyB; if (a.label === 'letter' && b.label === 'letter'){ removeEdge(a,b); } } }

function spawnLetter(letter){
  const w = playWrap.clientWidth, h = playWrap.clientHeight;
  const diameter = CONFIG.letterSize, radius = diameter/2;
  const x = randInt(CONFIG.spawnHorizontalPadding + radius, w - CONFIG.spawnHorizontalPadding - radius);
  const y = radius + 6;
  const body = Matter.Bodies.circle(x, y, radius, {
    restitution: 0.45,
    friction: 0.02,
    frictionAir: 0.02,
    label: 'letter',
    letter: (typeof letter === 'string' && letter.length>0) ? letter.toUpperCase() : 'A',
    spawnId: ++spawnCount,
    render: { visible:false }
  });
  Matter.Body.setDensity(body, 0.001 + Math.random()*0.002);
  Matter.World.add(world, body);
  lettersOnScreen++; lettersCountEl.textContent = lettersOnScreen; if (mobileLettersCount) mobileLettersCount.textContent = lettersOnScreen;
  return body;
}

/* Spawn until CONFIG.maxLetters (burst) — used after leveling up */
function spawnUntilMax(){
  return new Promise(resolve => {
    if (!running) { resolve(); return; }
    const target = CONFIG.maxLetters;
    const iv = setInterval(()=> {
      if (!running) { clearInterval(iv); resolve(); return; }
      if (lettersOnScreen >= target){
        clearInterval(iv);
        resolve();
        return;
      }
      const letter = String.fromCharCode(65 + Math.floor(Math.random()*26));
      spawnLetter(letter);
    }, CONFIG.fillBurstInterval);
  });
}

/* Burst-fill the box at game start */
function fillInitialLetters(){
  const target = Math.min(CONFIG.initialFillCount, CONFIG.maxLetters);
  const iv = setInterval(()=> {
    if (!running) { clearInterval(iv); return; }
    if (lettersOnScreen >= target){ clearInterval(iv); return; }
    const letter = String.fromCharCode(65 + Math.floor(Math.random()*26));
    spawnLetter(letter);
  }, CONFIG.fillBurstInterval);
}

function drawLetters(){
  try {
    const ctx = render.context;
    ctx.clearRect(0,0, render.canvas.width, render.canvas.height);
    const bodies = Matter.Composite.allBodies(world);
    const now = performance.now();

    // draw letter glyphs (only valid letter bodies)
    for (const b of bodies){
      try {
        if (b.label === 'letter' && typeof b.letter === 'string' && !b.isRemoved){
          const ch = (b.letter || 'A').toUpperCase();
          const glyph = glyphs[ch] || glyphs['A'];
          const size = CONFIG.letterSize;
          const alpha = (b.__fadeAlpha !== undefined) ? b.__fadeAlpha : 1;
          ctx.globalAlpha = alpha;
          ctx.drawImage(glyph, b.position.x - size/2, b.position.y - size/2, size, size);
        }
      } catch(e){ /* swallow drawing error for that body */ }
    }

    // selection/flash overlays (safely)
    for (const b of bodies){
      try {
        // HINT HIGHLIGHT (pulsing ring)
        if (b.__hint && !b.isRemoved){
          ctx.save();
          const t = ((now % 1200) / 1200);
          const pulse = 1 + (Math.sin(t * Math.PI * 2) * 0.06);
          const r = (b.circleRadius || CONFIG.letterSize / 2) * pulse + 4;
          ctx.lineWidth = 3;
          ctx.strokeStyle = '#ffd27a';
          ctx.beginPath();
          ctx.globalAlpha = 0.95;
          ctx.arc(b.position.x, b.position.y, r, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // STATIC WHITE STROKE FOR SELECTED LETTERS
        if (b.__selected && !b.isRemoved) {
            ctx.save();
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'white';
            ctx.beginPath();
            const r = (b.circleRadius || CONFIG.letterSize/2);
            ctx.arc(b.position.x, b.position.y, r + 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        if (b.label === 'letter' && b.letter && b.__flash && !b.isRemoved){
          const f = b.__flash;
          const t = clamp((now - f.start) / f.duration, 0, 1);
          const scale = 1 + (Math.sin(t * Math.PI) * f.maxScale);
          const alpha = 0.9 * (1 - Math.pow(t,0.9));
          const radius = (b.circleRadius || CONFIG.letterSize/2) * scale;
          ctx.globalAlpha = alpha;
          ctx.beginPath();
          ctx.fillStyle = f.color || '#fff59a';
          ctx.arc(b.position.x, b.position.y, radius, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
          const glyph = glyphs[b.letter] || glyphs['A'];
          const size = CONFIG.letterSize * scale;
          ctx.drawImage(glyph, b.position.x - size/2, b.position.y - size/2, size, size);
        }
      } catch(e){}
    }

    // particles
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      const age = performance.now() - p.start;
      const lifePct = 1 - age / p.life;
      if (lifePct <= 0){ particles.splice(i,1); continue; }
      p.vy += 0.06;
      p.x += p.vx; p.y += p.vy;
      ctx.globalAlpha = Math.max(0, lifePct);
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }

    // floating statuses (sanitized short text)
    for (let i = floatingStatuses.length - 1; i >= 0; i--){
      const s = floatingStatuses[i];
      const t = (now - s.start) / s.duration;
      if (t >= 1){ floatingStatuses.splice(i,1); continue; }
      const yy = s.y - (t * 40);
      const alpha = 1 - t;
      ctx.globalAlpha = alpha;
      ctx.font = `700 ${s.size}px Inter, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillText(s.text, s.x + 1, yy + 1);
      ctx.fillStyle = s.color;
      ctx.fillText(s.text, s.x, yy);
    }
    ctx.globalAlpha = 1;
  } catch (e) {
    console.error('drawLetters error', e);
  }
}

function worldPointFromEvent(evt){
  const rect = playWrap.getBoundingClientRect();
  const x = (evt.clientX || (evt.touches && evt.touches[0].clientX) || 0) - rect.left;
  const y = (evt.clientY || (evt.touches && evt.touches[0].clientY) || 0) - rect.top;
  return { x, y };
}

// clamp a desired position so a circular body stays inside the play area
function clampPositionToPlayWrap(x, y, radius){
  const w = playWrap.clientWidth || render.options.width;
  const h = playWrap.clientHeight || render.options.height;
  const minX = Math.max(radius, 0);
  const maxX = Math.max(radius, w - radius);
  const minY = Math.max(radius, 0);
  const maxY = Math.max(radius, h - radius);
  return { x: clamp(x, minX, maxX), y: clamp(y, minY, maxY) };
}
function getBodyRadius(b){ return (b && b.circleRadius) || (CONFIG.letterSize/2); }

// Long-press & connect-mode for mobile
let longPressTimer = null;
let longPressThreshold = 280; // ms
let touchMoveThreshold = 8;    // px - movement allowed while long-pressing
let touchStartPos = null;
let longPressTriggered = false;
let potentialDragBody = null; // on touch, remember initial body to start dragging if user moves

function onPointerDown(e){
  const p = worldPointFromEvent(e);
  pointer.isDown = true; pointer.x = p.x; pointer.y = p.y;
  const found = Matter.Query.point(Matter.Composite.allBodies(world), p);
  if (found.length){
    let body = null;
    for (let i=found.length-1;i>=0;i--){ if (found[i].label==='letter'){ body = found[i]; break; } }
    const isTouch = (e.pointerType === 'touch' || e.pointerType === 'pen');

    // store start pos for long-press detection
    touchStartPos = { x: p.x, y: p.y };
    longPressTriggered = false;
    if (longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }

    // Priority rules (updated):
    // - If effective connect mode (pinned OR Shift) -> selection
    // - If touch and not connect -> start long-press to select or prepare for drag
    // - If non-touch and not connect -> drag
    if (body){
      const eff = effectiveConnectModeForEvent(e);
      if (eff){
        startSelection(body);
        return;
      }
      if (isTouch){
        // on touch: remember the touched body — if user holds -> selection, if user moves -> drag
        potentialDragBody = body;
        longPressTimer = setTimeout(() => {
          longPressTriggered = true;
          // only start selection if still appropriate
          startSelection(body);
          longPressTimer = null;
          potentialDragBody = null;
        }, longPressThreshold);
        return;
      } else {
        // non-touch: normal dragging
        startDraggingBody(body, p);
        return;
      }
    } else {
      // no body found: still prepare long press cancellation state for touch
      if ((e.pointerType === 'touch' || e.pointerType === 'pen')){
        longPressTimer = setTimeout(() => { longPressTriggered = true; longPressTimer = null; }, longPressThreshold);
      }
    }
  } else {
    // no bodies: still set touch timers if touch
    if ((e.pointerType === 'touch' || e.pointerType === 'pen')){
      touchStartPos = { x: p.x, y: p.y };
      longPressTriggered = false;
      if (longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }
      longPressTimer = setTimeout(() => { longPressTriggered = true; longPressTimer = null; }, longPressThreshold);
    }
  }
}

function onPointerMove(e){
  if (!pointer.isDown) return;
  const p = worldPointFromEvent(e);
  pointer.x = p.x; pointer.y = p.y;
  const isTouch = (e.pointerType === 'touch' || e.pointerType === 'pen');

  // If we are waiting for a long-press, cancel it if user moved too far (interpreted as drag)
  if (longPressTimer && touchStartPos){
    const dx = p.x - touchStartPos.x;
    const dy = p.y - touchStartPos.y;
    if ((dx*dx + dy*dy) > (touchMoveThreshold * touchMoveThreshold)){
      clearTimeout(longPressTimer);
      longPressTimer = null;
      // if user touched a body and moved, start dragging that body
      if (potentialDragBody && !selectionActive && !dragging.body){
        startDraggingBody(potentialDragBody, p);
        potentialDragBody = null;
      }
    }
  }

  if (selectionActive){
    const found = Matter.Query.point(Matter.Composite.allBodies(world), p);
    if (found.length){
      let over = null;
      for (let i=found.length-1;i>=0;i--){ if (found[i].label==='letter'){ over = found[i]; break; } }
      if (over && !over.isRemoved && !selection.bodies.includes(over)){
        if (selection.bodies.length === 0){
          appendToSelection(over);
        } else {
          const last = selection.lastBody;
          const neigh = adjacency.get(last);
          if (neigh && neigh.has(over)){
            appendToSelection(over);
          }
        }
      }
    }
    return;
  }

  if (dragging.body){
    const b = dragging.body;
    const radius = getBodyRadius(b);
    const clamped = clampPositionToPlayWrap(p.x, p.y, radius);
    Matter.Body.setPosition(b, { x: clamped.x, y: clamped.y });
    Matter.Body.setAngle(b, 0);
    dragging.lastPos = { x: clamped.x, y: clamped.y };
    dragging.lastTime = performance.now();
  } else {
    // If a long-press triggered but we didn't have a body initially, start selection if now over a letter
    if (longPressTriggered && !selectionActive){
      const found = Matter.Query.point(Matter.Composite.allBodies(world), p);
      if (found.length){
        let body = null;
        for (let i=found.length-1;i>=0;i--){ if (found[i].label==='letter'){ body = found[i]; break; } }
        if (body) startSelection(body);
      }
    }
  }
}

function onPointerUp(e){
  pointer.isDown = false;
  const p = worldPointFromEvent(e);
  pointer.x = p.x; pointer.y = p.y;

  // clear any pending long-press timer
  if (longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }
  longPressTriggered = false;
  touchStartPos = null;
  potentialDragBody = null;

  if (selectionActive){
    finalizeSelection();
    return;
  }
  if (dragging.body) endDraggingBody();
}

// attach listeners
canvas.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointermove', onPointerMove);
window.addEventListener('pointerup', onPointerUp);

function startDraggingBody(body, p){
  dragging.body = body;
  dragging.lastPos = { x: p.x, y: p.y };
  dragging.lastTime = performance.now();
  // Clamp initial position to ensure body starts inside bounds
  const radius = getBodyRadius(body);
  const clamped = clampPositionToPlayWrap(body.position.x, body.position.y, radius);
  Matter.Body.setPosition(body, { x: clamped.x, y: clamped.y });
  Matter.Body.setStatic(body, true);
  try { Matter.World.remove(world, body); Matter.World.add(world, body); } catch(e){}
}
function endDraggingBody(){
  const body = dragging.body; if (!body) return;
  const now = performance.now();
  const dt = Math.max(1, now - (dragging.lastTime || now));
  const last = dragging.lastPos || { x: body.position.x, y: body.position.y };
  let vx = (pointer.x - last.x) / (dt/1000);
  let vy = (pointer.y - last.y) / (dt/1000);

  // Before releasing, clamp the body's position back inside the play area
  const radius = getBodyRadius(body);
  const clamped = clampPositionToPlayWrap(body.position.x, body.position.y, radius);
  Matter.Body.setPosition(body, { x: clamped.x, y: clamped.y });

  // If the pointer was outside the area (causing a large velocity), damp it so the body doesn't shoot out
  const maxVx = 20, maxVy = 30;
  vx = clamp(vx * 0.2, -maxVx, maxVx);
  vy = clamp(vy * 0.2, -maxVy, maxVy);

  Matter.Body.setStatic(body, false);
  Matter.Body.setVelocity(body, { x: vx, y: vy });
  dragging.body = null; dragging.lastPos = null;
}

function startSelection(firstBody){
  selectionActive = true;
  selection.bodies = [];
  selection.lastBody = null;
  if (runner) runner.enabled = false;
  appendToSelection(firstBody);
}
function appendToSelection(b){
  if (!b || b.isRemoved) return;
  selection.bodies.push(b);
  selection.lastBody = b;
  b.__flash = { start: performance.now(), duration: 600, color: '#60a5fa', maxScale: 0 };
  b.__selected = true;
}
async function finalizeSelection(){
  selectionActive = false;
  const seq = selection.bodies.map(b => (b.letter||'').toLowerCase()).join('');
  const cx = selection.bodies.reduce((s, b) => s + b.position.x, 0) / Math.max(1, selection.bodies.length || 1);
  const cy = selection.bodies.reduce((s, b) => s + b.position.y, 0) / Math.max(1, selection.bodies.length || 1);
  const clearSelectionVisuals = () => {
    for (const b of selection.bodies){ if (b){ b.__flash = null; b.__selected = false; } }
    selection.bodies = []; selection.lastBody = null;
  };
  if (seq.length >= CONFIG.wordMinLength){
    try {
      const isWord = await dictContainsAsync(seq);
      if (isWord){
        await flashPauseAndRemove(selection.bodies.slice(), seq);
        if (runner) runner.enabled = true;
        clearSelectionVisuals();
        return;
      } else {
        showFloatingStatus('Invalid word', cx, cy, { color: '#ff7b7b', size: 16, duration: 1000 });
        clearSelectionVisuals();
        if (runner) runner.enabled = true;
        return;
      }
    } catch (err){
      console.error('dict lookup error', err);
      showFloatingStatus('Dictionary error', cx, cy, { color: '#ff7b7b', size: 16, duration: 1200 });
      clearSelectionVisuals();
      if (runner) runner.enabled = true;
      return;
    }
  } else {
    showFloatingStatus('Too short', cx, cy, { color: '#ff7b7b', size: 16, duration: 1000 });
    clearSelectionVisuals();
    if (runner) runner.enabled = true;
  }
}

function getLetterBodies(){ return Matter.Composite.allBodies(world).filter(b => b.label === 'letter' && !b.isRemoved); }
function buildLetterCounts(bodies){ const counts = {}; for (const b of bodies){ const ch = (b.letter || '').toLowerCase(); if (!ch) continue; counts[ch] = (counts[ch]||0) + 1; } return counts; }
function canFormWordFromCounts(word, counts){ const temp = {}; for (const ch of word){ temp[ch] = (temp[ch]||0) + 1; if ((counts[ch]||0) < temp[ch]) return false; } return true; }
function findConnectedSubsetForWord(clusterBodies, word){ return null; }
function processClusterForAnagrams(clusterBodies){ return false; }
function detectClustersAndRemoveWords(){ /* intentionally no-op in SHIFT-mode */ }

function flashPauseAndRemove(bodies, word){
  return new Promise(resolve => {
    if (!bodies || bodies.length === 0){ resolve(false); return; }
    animationPlaying = true;
    if (runner) runner.enabled = false;
    const start = performance.now();
    const duration = CONFIG.flashPauseMs;
    const flashColor = '#fff59a';
    for (const b of bodies){ b.__flash = { start, duration, color: flashColor, maxScale: 0.9 }; }
    setTimeout(()=> {
      for (const b of bodies){ if (b) b.__flash = null; }
      fadeAndRemoveBodies(bodies, word).then(()=> {
        animationPlaying = false;
        if (runner) runner.enabled = true;
        resolve(true);
      });
    }, duration);
  });
}
function fadeAndRemoveBodies(bodies, word){
  return new Promise(resolve => {
    const group = bodies.filter(b => b && !b.isRemoved);
    if (!group.length){ resolve(); return; }

    const len = (word || '').length;
    const basePoints = len * CONFIG.scorePerLetter;

    // If any body was marked as a hint recently, treat this as a HINTED match and
    // do NOT grant rarity bonuses, floating rarity status, or rarity tags.
    const hinted = group.some(b => !!b.__hint);

    // Compute rarity & bonus only when NOT hinted
    const rarity = hinted ? 'common' : computeRarity(word);
    const rarityBonus = (!hinted && rarity !== 'common') ? (RARITY_BONUS[rarity] || 0) : 0;
    const totalPoints = basePoints + rarityBonus;

    // Player-formed words count toward both the total score and progression score
    score += totalPoints;
    progressScore += totalPoints;
    scoreEl.textContent = score;
    if (hudScore) hudScore.textContent = score;

    // store richer metadata for the recent words UI
    wordsMatched.unshift({ word: String(word||'').toUpperCase(), points: totalPoints, basePoints, rarity, hinted });
    /* keep full history of connected words (no 12-item cap) */
    refreshRecentWords();

    wordsCountEl.textContent = parseInt(wordsCountEl.textContent || '0') + 1; if (mobileWordsCount) mobileWordsCount.textContent = wordsCountEl.textContent;

    let cx = 0, cy = 0;
    for (const b of group){ if (!b) continue; cx += b.position.x; cy += b.position.y; spawnExplosion(b.position.x, b.position.y, 6, '#fff'); }
    cx /= group.length; cy /= group.length;

    // Show floating word + points only if this wasn't a hinted match
    if (!hinted){
      showFloatingStatus(`${String(word||'').toUpperCase()} +${totalPoints}`, cx, cy, { color: '#e6f6ff', size: 18, duration: 1200 });
      // show separate floating rarity label (smaller and above) for rarer-than-common
      if (rarity !== 'common'){
        const color = RARITY_COLORS[rarity] || RARITY_COLORS.common;
        showFloatingStatus(`${rarityLabel(rarity)} word!`, cx, cy - 30, { color, size: 14, duration: 1100 });
      }
    } else {
      // For hinted words the spec asked to not show floating status for rarity.
      // We still show the base word+points? The user requested no floating status at all for hinted words.
      // Following that: do NOT show floating status for hinted words.
    }

        // Note: your existing handleComboOnMatch(false) expects whether hint used. We still call it with 'false'
    // because we break combos earlier when a hint is requested. If you want the combo handler to consider
    // the 'hinted' flag, update handleComboOnMatch to accept that parameter.
    handleComboOnMatch(false);

    for (const b of group){ b.isRemoved = true; clearEdgesForBody(b); }

    checkLevelProgress();

    const start = performance.now();
    const dur = CONFIG.fadeDuration;
    function tick(){
      const t = (performance.now() - start) / dur;
      if (t >= 1){
        for (const b of group){ try{ Matter.World.remove(world, b); } catch(e){} lettersOnScreen = Math.max(0, lettersOnScreen - 1); }
        lettersCountEl.textContent = lettersOnScreen; if (mobileLettersCount) mobileLettersCount.textContent = lettersOnScreen;
        resolve();
        return;
      } else {
        for (const b of group) b.__fadeAlpha = 1 - t;
        requestAnimationFrame(tick);
      }
    }
    requestAnimationFrame(tick);
  });
}

let comboStreak = 0; // consecutive word matches without hint
let comboExpiresAt = 0; // timestamp in ms when combo expires
let comboTimerIv = null;

function getComboBonusForStreak(n){
  if (n < CONFIG.comboStartThreshold) return 0;
  if (n < CONFIG.comboBonuses.length) return CONFIG.comboBonuses[n];
  return CONFIG.comboMaxBonusFrom7;
}
function getComboDurationForStreak(n){
  if (n < CONFIG.comboStartThreshold) return 0;
  // 3 => base (comboDurationAt3), 4 => -decrease, etc
  const levelIndex = n - CONFIG.comboStartThreshold; // 0 for 3rd
  const dur = CONFIG.comboDurationAt3 - (levelIndex * CONFIG.comboDurationDecreasePerLevel);
  return Math.max(CONFIG.comboDurationMin, dur);
}

function startComboTimer(){
  if (comboTimerIv) clearInterval(comboTimerIv);
  comboTimerIv = setInterval(()=>{
    updateComboBar();
    if (comboExpiresAt && performance.now() >= comboExpiresAt){
      // combo expired
      showFloatingStatus('Combo expired', render.options.width/2, 60, { color:'#ff7b7b', size:14, duration:900 });
      resetCombo();
    }
  }, 120);
}
function stopComboTimer(){ if (comboTimerIv) { clearInterval(comboTimerIv); comboTimerIv = null; } }

function updateComboBar(){
  if (!comboExpiresAt){ comboWrap.style.display = 'none'; comboBarInnerEl.style.width = '0%'; comboTextEl.textContent = 'Combo x0'; return; }
  const remaining = Math.max(0, comboExpiresAt - performance.now());
  const dur = getComboDurationForStreak(comboStreak) * 1000;
  if (dur <= 0){ comboWrap.style.display = 'none'; comboBarInnerEl.style.width = '0%'; return; }
  const pct = clamp((remaining / dur) * 100, 0, 100);
  comboWrap.style.display = 'block';
  comboBarInnerEl.style.width = `${pct}%`;
  comboTextEl.textContent = `Combo x${comboStreak}`;
}

function resetCombo(reason){
  comboStreak = 0;
  comboExpiresAt = 0;
  stopComboTimer();
  updateComboBar();
}

function handleComboOnMatch(wasHintUsed){
  // If a hint was used recently, reset the combo streak
  if (wasHintUsed){ resetCombo('hint'); return; }
  comboStreak += 1;
  // Only apply bonus from the threshold
  const bonus = getComboBonusForStreak(comboStreak);
  if (bonus > 0){
    // apply combo bonus to both total score and progression score
    score += bonus;
    progressScore += bonus;
    scoreEl.textContent = score;
    if (hudScore) hudScore.textContent = score;
    updateLevelUI();
    // show floating and play particles
    showFloatingStatus(`Combo +${bonus}`, render.options.width/2, 80, { color: '#ffd27a', size: 16, duration: 1400 });
    spawnExplosion(render.options.width/2, 80, 12, '#ffd27a');
    // reset combo timer to the duration for this streak
    const durSec = getComboDurationForStreak(comboStreak);
    comboExpiresAt = performance.now() + durSec * 1000;
    startComboTimer();
    updateComboBar();
  } else {
    // below threshold: still increment streak but do not start timer yet
    // if streak reached the threshold exactly, start timer and award
    if (comboStreak === CONFIG.comboStartThreshold){
      const bonus2 = getComboBonusForStreak(comboStreak);
      if (bonus2 > 0){
        score += bonus2;
        progressScore += bonus2;
        scoreEl.textContent = score;
        if (hudScore) hudScore.textContent = score;
        updateLevelUI();
        showFloatingStatus(`Combo +${bonus2}`, render.options.width/2, 80, { color: '#ffd27a', size: 16, duration: 1400 });
        spawnExplosion(render.options.width/2, 80, 12, '#ffd27a');
      }
      const durSec = getComboDurationForStreak(comboStreak);
      comboExpiresAt = performance.now() + durSec * 1000;
      startComboTimer();
      updateComboBar();
    }
  }
}

/* When player requests a hint, that should break combos */
function breakComboDueToHint(){
  if (comboStreak > 0) showFloatingStatus('Combo broken (hint)', render.options.width/2, 90, { color:'#ff7b7b', size:14, duration:1400 });
  resetCombo('hint');
}

function computeScoreNeededForLevel(lv){
  const n = Math.max(0, lv - 1);
  const a = CONFIG.levelScoreIncrement;
  const d = CONFIG.levelScoreIncrementGrowth;
  return CONFIG.levelBaseScore + (n * a) + (d * (n * (n - 1) / 2));
}
function checkLevelProgress(){
  updateLevelUI();
  const needed = computeScoreNeededForLevel(level);
  if (progressScore >= needed){
    level += 1;
    progressScore = 0;
    applyLevelUpEffects();
    updateLevelUI();
  }
}
function updateLevelUI(){
  levelNumEl.textContent = String(level);
  if (mobileLevelNum) mobileLevelNum.textContent = String(level);
  const needed = computeScoreNeededForLevel(level);
  const progress = clamp((progressScore) / Math.max(1, needed), 0, 1);
  levelProgressTextEl.textContent = `Progress: ${progressScore}/${needed}`;
  if (mobileLevelProgressText) mobileLevelProgressText.textContent = `Progress: ${progressScore}/${needed}`;
  const pct = Math.round(progress * 100);
  levelBarInnerEl.style.width = `${pct}%`;
  if (mobileLevelBarInner) mobileLevelBarInner.style.width = `${pct}%`;
}
function applyLevelUpEffects(){
  if (level > 1 && ((level - 1) % 2 === 0)){
    CONFIG.maxLetters += 15;
    setTimeout(() => {
      showFloatingStatus(
        `Capacity increased to ${CONFIG.maxLetters}`,
        render.options.width / 2,
        90,
        { color: '#60a5fa', size: 14, duration: 1600 }
      );
    }, 300);
  }
  const letters = getLetterBodies().filter(b => !b.isRemoved);
  const toRemoveCount = Math.floor(letters.length * CONFIG.removeFractionOnLevel);
  if (toRemoveCount > 0){
    const chosen = [];
    const pool = letters.slice();
    for (let i=0;i<toRemoveCount;i++){ if (pool.length === 0) break; const idx = Math.floor(Math.random()*pool.length); chosen.push(pool[idx]); pool.splice(idx,1); }
    const pts = chosen.length * CONFIG.pointsPerRemovedLetter;
    showFloatingStatus(`Level up! Clearing ${chosen.length} letters. +${pts}`, render.options.width/2, 60, { color: '#fff59a', size: 16, duration: 1800 });
    for (const b of chosen){ if (b) spawnExplosion(b.position.x, b.position.y, 8, '#ffd27a'); }

    // suspend async checks until refill completes
    suspendChecksDuringFill = true;
    removeLettersForLevelUp(chosen, pts);

  } else {
    showFloatingStatus(`Level up! +0`, render.options.width/2, 60, { color: '#fff59a', size: 14, duration: 1400 });
  }

  // refill after short delay; resume async checks only when spawnUntilMax finishes
  setTimeout(() => {
    spawnUntilMax().then(() => {
      // refill complete -> allow async checks again (if game still running)
      suspendChecksDuringFill = false;
      if (running) startAsyncGameChecks();
    });
  }, 360);

  updateLevelUI();
}
function removeLettersForLevelUp(bodies, pts){
  if (!bodies || bodies.length === 0) return;
  score += pts;
  scoreEl.textContent = score;
  if (hudScore) hudScore.textContent = score;
  for (const b of bodies){ if (!b || b.isRemoved) continue; b.isRemoved = true; clearEdgesForBody(b); }
  const start = performance.now();
  const dur = 260;
  function tick(){
    const t = (performance.now() - start) / dur;
    if (t >= 1){
      for (const b of bodies){ try{ Matter.World.remove(world, b); } catch(e){} lettersOnScreen = Math.max(0, lettersOnScreen - 1); }
      lettersCountEl.textContent = lettersOnScreen; if (mobileLettersCount) mobileLettersCount.textContent = lettersOnScreen;
      return;
    } else { for (const b of bodies) if (b) b.__fadeAlpha = 1 - t; requestAnimationFrame(tick); }
  }
  requestAnimationFrame(tick);
}

async function findConnectedWordHint(){
  const bodies = getLetterBodies();
  const visited = new Set();
  const components = [];
  for (const b of bodies){ if (visited.has(b)) continue; const comp = []; const q = [b]; visited.add(b); while (q.length){ const cur = q.pop(); comp.push(cur); const neighs = adjacency.get(cur); if (neighs){ for (const n of neighs){ if (!visited.has(n) && !n.isRemoved){ visited.add(n); q.push(n); } } } } if (comp.length) components.push(comp); }
  for (const comp of components){
    const compSet = new Set(comp);
    comp.sort((a,b)=>a.spawnId - b.spawnId);
    const found = await searchComponentForWord(comp);
    if (found) return found;
  }
  return null;
}

async function searchComponentForWord(comp){
  const maxDepth = CONFIG.hintMaxDepth;
  const startTime = performance.now();
  const timeLimit = CONFIG.hintSearchMillisPerMode;
  let best = null;
  let bestScore = 0;
  let nodesExplored = 0;

  async function dfs(path){
    if (performance.now() - startTime > timeLimit) return;
    if (nodesExplored++ > CONFIG.hintMaxNodes) return;
    const seq = path.map(b=>b.letter.toLowerCase()).join('');
    if (seq.length >= CONFIG.wordMinLength){
      const isWord = await dictContainsAsync(seq);
      if (isWord){
        const score = seq.length;
        if (score > bestScore){ bestScore = score; best = path.slice(); }
      }
    }
    if (seq.length >= maxDepth) return;
    const isPref = await dictIsPrefixAsync(seq);
    if (!isPref) return;
    const last = path[path.length-1];
    const neighs = Array.from(adjacency.get(last) || []).filter(x=>!x.isRemoved && !path.includes(x));
    for (const n of neighs){ await dfs(path.concat(n)); if (performance.now() - startTime > timeLimit) return; if (nodesExplored > CONFIG.hintMaxNodes) return; }
  }

  for (const b of comp){ await dfs([b]); if (performance.now() - startTime > timeLimit) break; if (nodesExplored > CONFIG.hintMaxNodes) break; }
  return best;
}

async function findAnyWordFromBoard(){
  const bodies = getLetterBodies();
  if (!bodies.length) return null;
  const startTime = performance.now();
  const timeLimit = CONFIG.hintSearchMillisPerMode;
  const maxDepth = CONFIG.hintMaxDepth;
  let nodesExplored = 0;
  let best = null;
  let bestScore = 0;

  async function dfs(path, used){
    if (performance.now() - startTime > timeLimit) return;
    if (nodesExplored++ > CONFIG.hintMaxNodes) return;
    const seq = path.map(b=>b.letter.toLowerCase()).join('');
    if (seq.length >= CONFIG.wordMinLength){
      const isWord = await dictContainsAsync(seq);
      if (isWord){
        const score = seq.length;
        if (score > bestScore){ bestScore = score; best = path.slice(); }
      }
    }
    if (seq.length >= maxDepth) return;
    const isPref = await dictIsPrefixAsync(seq);
    if (!isPref) return;
    for (const b of bodies){ if (used.has(b) || b.isRemoved) continue; used.add(b); await dfs(path.concat(b), used); used.delete(b); if (performance.now() - startTime > timeLimit) return; if (nodesExplored > CONFIG.hintMaxNodes) return; }
  }

  for (const b of bodies){ const used = new Set([b]); await dfs([b], used); if (performance.now() - startTime > timeLimit) break; if (nodesExplored > CONFIG.hintMaxNodes) break; }
  return best;
}

async function findHintCandidate(){
  await dictLoadedPromise; // ensure dictionary available
  const connected = await findConnectedWordHint();
  if (connected && connected.length) return connected;
  const any = await findAnyWordFromBoard();
  return any;
}

function applyHintToBodies(bodies){
  for (const b of getLetterBodies()) b.__hint = false;
  if (!bodies || !bodies.length) return;
  for (const b of bodies){ b.__hint = true; }
  setTimeout(()=>{ for (const b of bodies){ if (b) b.__hint = false; } }, CONFIG.hintHighlightMs);
}

/* Public: call when player asks for hint (or when the game wants to auto-check) */
async function provideHint(){
  if (!running) return;
  // Using a hint breaks the combo streak immediately
  breakComboDueToHint();
  const candidate = await findHintCandidate();
  if (candidate){
    applyHintToBodies(candidate);
    const word = candidate.map(b=>b.letter).join('');
    showFloatingStatus(`Hint: ${word}`, render.options.width/2, 60, { color: '#ffd27a', size: 14, duration: 1200 });
    return true;
  } else {
    // no possible word from board -> game over
    showFloatingStatus('No possible words - Game Over', render.options.width/2, 60, { color: '#ff7b7b', size: 14, duration: 1400 });
    endGame();
    return false;
  }
}

// Evaluate whether ANY word is possible (used by game over check)
async function hasAnyPlayableWord(){
  const candidate = await findHintCandidate();
  return !!candidate;
}

// We'll run periodic asynchronous checks (every 2s) to detect impossible boards
let asyncGameCheckIv = null;
let suspendChecksDuringFill = false; // new flag to prevent premature game-over checks
function startAsyncGameChecks(){
  if (asyncGameCheckIv) clearInterval(asyncGameCheckIv);
  asyncGameCheckIv = setInterval(async ()=>{
    if (!running) return;
    if (suspendChecksDuringFill) return;          // <- don't run checks while suspended
    // If there are very few letters, skip expensive check
    const bodies = getLetterBodies();
    if (!bodies.length) return;
    const possible = await hasAnyPlayableWord();
    if (!possible){
      // end game
      showFloatingStatus('No possible words - Game Over', render.options.width/2, 60, { color: '#ff7b7b', size: 14, duration: 1600 });
      endGame();
    }
  }, 2000);
}
function stopAsyncGameChecks(){ if (asyncGameCheckIv) clearInterval(asyncGameCheckIv); asyncGameCheckIv = null; }

function refreshRecentWords(){
  recentWordsEl.innerHTML = '';
  if (!wordsMatched.length){
    recentWordsEl.innerHTML = '<p class="muted">No words yet.</p>'; return;
  }
  for (const w of wordsMatched){
    const p = document.createElement('p');
    p.style.margin = '6px 0';
    p.style.lineHeight = '1.2';

    const strong = document.createElement('strong');
    strong.style.color = '#e6f6ff';
    strong.textContent = w.word;
    p.appendChild(strong);

    // If this match was hinted, we intentionally do NOT show the rarity tag (per spec)
    // ---- replace the old inline-style tag creation with this ----
    if (!w.hinted && w.rarity && w.rarity !== 'common') {
      // Create a modern pill-style rarity tag
      const tag = document.createElement('span');
      // class: 'rarity-tag' + ' rarity-<bucket>'
      tag.className = `rarity-tag rarity-${w.rarity}`;
      // readable label, uppercase
      tag.textContent = rarityLabel(w.rarity);

      // Optionally add a small tooltip and aria label
      tag.setAttribute('title', `${rarityLabel(w.rarity)} word`);
      tag.setAttribute('aria-hidden', 'true');

      p.appendChild(tag);
    }


    const span = document.createElement('span');
    span.style.color = 'var(--muted)';
    span.style.marginLeft = '8px';
    span.textContent = `+${w.points}`;
    p.appendChild(span);

    recentWordsEl.appendChild(p);
  }

  // --- Mobile recent-words sync (robust) ---
  try {
    const ml = document.getElementById('mobileWordList');
    if (ml) {
      ml.innerHTML = '';
      if (!wordsMatched || !wordsMatched.length) {
        const placeholder = document.createElement('div');
        placeholder.className = 'word-pill muted';
        placeholder.textContent = 'No words yet';
        ml.appendChild(placeholder);
      } else {
        for (const w of wordsMatched) {
          const pill = document.createElement('div');
          pill.className = 'word-pill';
          // Add a small visual hint for rarity on mobile (non-intrusive)
          if (!w.hinted && w.rarity && w.rarity !== 'common') {
            pill.classList.add('rarity-' + w.rarity);
          }
          pill.textContent = (w.word || '').toUpperCase();
          ml.appendChild(pill);
        }
      }
    }
  } catch (e) { console.warn('mobile recent words sync failed', e); }
  // --- end mobile sync ---

}

function startGame(){
  if (!engine) initMatter();
  resetWorldForNewGame();
  running = true; gameOver = false;
  score = 0; progressScore = 0;
  scoreEl.textContent = score;
  if (hudScore) hudScore.textContent = score;
  wordsMatched = []; refreshRecentWords();
  // ALSO ensure the mobile recent-words strip is reset immediately (robust clearing)
  try { const ml = document.getElementById('mobileWordList'); if (ml) { ml.replaceChildren(); const ph = document.createElement('div'); ph.className = 'word-pill muted'; ph.textContent = 'No words yet'; ml.appendChild(ph); } } catch(e){}
  lettersOnScreen = 0; lettersCountEl.textContent = 0; if (mobileLettersCount) mobileLettersCount.textContent = 0;
  wordsCountEl.textContent = 0; if (mobileWordsCount) mobileWordsCount.textContent = 0;
  level = 1;
  updateLevelUI();
  pauseBtn.textContent = 'Pause';
  fillInitialLetters();
  startTime = performance.now();
  if (elapsedTimer) clearInterval(elapsedTimer);
  elapsedTimer = setInterval(updateTimer, 500);
  startAsyncGameChecks();
  // reset combos on new game
  resetCombo('newgame');
}
function resetWorldForNewGame(){
  if (!world) return;
  const bodies = Matter.Composite.allBodies(world).slice();
  for (const b of bodies){ if (b.label === 'letter'){ try{ Matter.World.remove(world, b); } catch(e){} clearEdgesForBody(b); } }
  adjacency.clear();
  lettersOnScreen = 0; lettersCountEl.textContent = 0; if (mobileLettersCount) mobileLettersCount.textContent = 0;
}
function togglePause(){ if (!running) return; if (runner && runner.enabled){ runner.enabled = false; pauseBtn.textContent = 'Resume'; mobilePauseBtn && (mobilePauseBtn.textContent = 'Resume'); } else { runner.enabled = true; pauseBtn.textContent = 'Pause'; mobilePauseBtn && (mobilePauseBtn.textContent = 'Pause'); } }
function endGame(){ running = false; gameOver = true; startBtn.textContent = 'Restart'; pauseBtn.textContent = 'Pause'; stopAsyncGameChecks(); if (elapsedTimer) clearInterval(elapsedTimer); setTimeout(()=> { showGameOverOverlay(`Score: ${score} Words: ${wordsMatched.length}`); }, 80); }
function showGameOverOverlay(text){
  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.left = '50%';
  overlay.style.top = '50%';
  overlay.style.transform = 'translate(-50%,-50%)';
  overlay.style.padding = '20px';
  overlay.style.background = 'linear-gradient(180deg, rgba(2,6,23,0.92), rgba(2,6,23,0.98))';
  overlay.style.border = '1px solid rgba(255,255,255,0.04)';
  overlay.style.borderRadius = '12px';
  overlay.style.zIndex = 999;
  overlay.style.textAlign = 'center';
  overlay.style.color = '#e6f6ff';
  overlay.innerHTML = `<div style="font-weight:700;font-size:18px;margin-bottom:8px">Game Over</div>                        <div style="color:var(--muted);margin-bottom:14px">${String(text).replace(/\n/g,'<br>')}</div>                        <div style="display:flex;gap:8px;justify-content:center">                          <button id="goRestart" class="btn">Restart</button>                          <button id="goClose" class="ghost">Close</button>                        </div>`;
  playWrap.appendChild(overlay);
  document.getElementById('goRestart').addEventListener('click', ()=>{ playWrap.removeChild(overlay); startGame(); });
  document.getElementById('goClose').addEventListener('click', ()=>{ playWrap.removeChild(overlay); });
}

/* Timer */
function updateTimer(){ if (!startTime) return; const diff = Math.floor((performance.now() - startTime)/1000); const mm = String(Math.floor(diff/60)).padStart(2,'0'); const ss = String(diff%60).padStart(2,'0'); timerEl.textContent = `${mm}:${ss}`; if (hudTimer) hudTimer.textContent = `${mm}:${ss}`; }

/* UI wiring */
startBtn.addEventListener('click', ()=> startGame());
pauseBtn.addEventListener('click', ()=> togglePause());
hintBtn.addEventListener('click', ()=> provideHint());

// wire mobile buttons to same actions where appropriate
if (mobileStartBtn) mobileStartBtn.addEventListener('click', ()=> startBtn.click());
if (mobilePauseBtn) mobilePauseBtn.addEventListener('click', ()=> pauseBtn.click());
if (mobileHintBtn) mobileHintBtn.addEventListener('click', ()=> hintBtn.click());
// mobileMenuBtn will toggle the right panel (off-canvas)
if (mobileMenuBtn) mobileMenuBtn.addEventListener('click', ()=>{ const open = rightPanel.classList.toggle('open'); mobileOverlay.classList.toggle('show', open); if (open) { rightPanel.setAttribute('tabindex','-1'); rightPanel.focus(); } });

// Dictionary worker
const dictWorker = new Worker('./dictWorker.js');
let dictLoaded = false;
let dictLoadedResolve;
const dictLoadedPromise = new Promise(res => dictLoadedResolve = res);
let dictNextId = 1;
const dictPending = new Map();
startBtn.disabled = true; const originalStartText = startBtn.textContent || 'Start'; startBtn.textContent = 'Loading dictionary...';

dictWorker.onmessage = (ev) => {
  const d = ev.data;
  if (d.type === 'progress'){
    startBtn.textContent = `Loading dictionary... (${d.pct || Math.round((d.loaded||0)/1000)}%)`;
  } else if (d.type === 'loaded'){
    dictLoaded = true; dictLoadedResolve(); startBtn.disabled = false; startBtn.textContent = originalStartText; showFloatingStatus(`Dictionary loaded (${d.count} words)`, render ? render.options.width/2 : 200, 40, { color:'#7dd3fc', size:16, duration:1400 });
  } else if (d.type === 'contains' || d.type === 'isPrefix'){
    const resolver = dictPending.get(d.id);
    if (resolver){ resolver(d.result); dictPending.delete(d.id); }
  } else if (d.type === 'error'){
    console.error('dictWorker error:', d.message);
    startBtn.textContent = 'Start (dict load failed)';
    startBtn.disabled = false;
  }
};

dictWorker.postMessage({ type: 'loadUrl', url: './wordlist.txt', estimated: 200000 });

function dictContainsAsync(word){
  return new Promise(resolve => {
    dictLoadedPromise.then(() => { const id = dictNextId++; dictPending.set(id, resolve); dictWorker.postMessage({ type: 'contains', id, word }); });
  });
}
function dictIsPrefixAsync(pref){
  return new Promise(resolve => {
    dictLoadedPromise.then(() => { const id = dictNextId++; dictPending.set(id, resolve); dictWorker.postMessage({ type: 'isPrefix', id, pref }); });
  });
}

/* MOBILE SETUP: auto-enable connect mode on touch devices + one-time hint overlay */

function mobileInit(){
  const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.matchMedia('(pointer:coarse)').matches || window.innerWidth < 800;
  if (isTouch){
    updateConnectToggleUI();
    // tweak the instructions text for mobile
    const note = document.getElementById('controlsNote');
    if (note) note.innerHTML = 'Hold & drag to connect the letters. Release to submit the sequence as a word.';

    // show one-time overlay hint (store in localStorage)
    try {
      if (!localStorage.getItem('lr_seen_mobile_hint')){
        showMobileHintOverlay();
        localStorage.setItem('lr_seen_mobile_hint', '1');
      }
    } catch(e){}
  } else {
    // make sure pinnedConnectMode isn't accidentally left on for non-touch layouts
    // but do not force-disable if user explicitly pinned it earlier.
    // we only clear the transientConnectMode here.
    transientConnectMode = false;
    updateConnectToggleUI();
  }

  // show mobile-ui and mobile buttons on small screens
  const smallScreen = window.innerWidth <= 980 || (window.matchMedia && window.matchMedia('(pointer:coarse)').matches);
  if (smallScreen){
    if (mobileUI) mobileUI.style.display = 'block';
    if (mobileButtons) mobileButtons.style.display = 'block';
    // ensure the floating sidebar toggle is visible on small screens so users can open the panel
    if (sidebarToggle) sidebarToggle.style.display = 'block';
    // when mobile, keep rightPanel closed off-canvas and hide overlay
    if (rightPanel) rightPanel.classList.remove('open');
    if (mobileOverlay) mobileOverlay.classList.remove('show');
  } else {
    if (mobileUI) mobileUI.style.display = 'none';
    if (mobileButtons) mobileButtons.style.display = 'none';
    // hide the floating sidebar toggle on larger screens (desktop layout shows controls)
    if (sidebarToggle) sidebarToggle.style.display = 'none';
    // ensure the off-canvas overlay is hidden
    if (mobileOverlay) mobileOverlay.classList.remove('show');
    if (rightPanel) rightPanel.classList.remove('open');
  }
}

// ensure UI responds to load and resize so switching between desktop/mobile layouts is seamless
function refreshResponsiveUI(){
  try{ mobileInit(); updateBoundaries(); }catch(e){}
}
window.addEventListener('load', refreshResponsiveUI);
window.addEventListener('resize', refreshResponsiveUI);
function showMobileHintOverlay(){
  const ov = document.createElement('div');
  ov.style.position = 'fixed';
  ov.style.left = '12px';
  ov.style.right = '12px';
  ov.style.top = '12px';
  ov.style.padding = '12px';
  ov.style.zIndex = 9999;
  ov.style.backdropFilter = 'blur(6px)';
  ov.style.borderRadius = '12px';
  ov.style.background = 'linear-gradient(180deg, rgba(2,6,23,0.9), rgba(2,6,23,0.8))';
  ov.style.border = '1px solid rgba(255,255,255,0.04)';
  ov.style.color = '#e6f6ff';
  ov.innerHTML = `<div style="font-weight:700;margin-bottom:8px">Tip: touch controls</div><div style="color:var(--muted);font-size:14px">Long-press a letter then slide across adjacent letters to form a word, or enable Connect Mode. Tap anywhere to dismiss.</div>`;
  ov.addEventListener('pointerup', ()=>{ try{ document.body.removeChild(ov); }catch(e){} });
  document.body.appendChild(ov);
}

/* Off-canvas / sidebar toggle handlers (mobile) */
sidebarToggle.addEventListener('click', ()=>{
  const open = rightPanel.classList.toggle('open');
  mobileOverlay.classList.toggle('show', open);
  if (open) {
    // ensure rightPanel is focusable for a11y
    rightPanel.setAttribute('tabindex','-1');
    rightPanel.focus();
  }
});
mobileOverlay.addEventListener('click', ()=>{
  rightPanel.classList.remove('open');
  mobileOverlay.classList.remove('show');
});

function pushWord(word){ if (!word) return; // remove placeholder if present
  const ml = document.getElementById('mobileWordList');
  try {
    if (ml && ml.children.length === 1 && ml.children[0].textContent.trim() === 'No words yet') ml.replaceChildren();
  } catch(e) { if (ml && ml.children.length === 1 && ml.children[0].textContent.trim() === 'No words yet') ml.innerHTML = ''; }
  const pill = document.createElement('div'); pill.className = 'word-pill'; pill.textContent = word.toUpperCase();
  if (ml) ml.insertBefore(pill, ml.firstChild);
}

/* init */
function init(){ initMatter(); scoreEl.textContent = '0'; timerEl.textContent = '00:00'; lettersCountEl.textContent = '0'; wordsCountEl.textContent = '0'; wordsMatched = []; refreshRecentWords(); level = 1; progressScore = 0; updateLevelUI(); resetCombo('init'); mobileInit(); updateConnectToggleUI(); }
init();
</script>

<script>
  async function initRarityFromJSON(path = './rarity_map.json'){
  try{
  const resp = await fetch(path, { cache: 'no-cache' });
  if (!resp.ok) throw new Error('fetch failed: ' + resp.status);
  const j = await resp.json();
  if (!j || !j.map) throw new Error('invalid json');
  // Accept either nested map or a compact map where missing words are common
  rarityMap = j.map || j;
  rarityThresholds = j.thresholds || rarityThresholds || {};
  trySaveToStorage(rarityMap);
  console.log('Rarity: loaded from JSON (', path, ') entries:', Object.keys(rarityMap).length);
  return true;
  } catch (e){
  console.warn('initRarityFromJSON failed:', e);
  return false;
  }
  }

  async function initRarityPreferJSON(){
  // JSON-only behavior enforced: try cache, then try JSON from server. No fallback to wordlist.
  if (tryLoadFromStorage()) return true;
  const ok = await initRarityFromJSON('./rarity_map.json');
  return !!ok;
}

function buildRarityFromWordlistNgramsSync(words, n = 3){
  const ngramCounts = Object.create(null);
  const add = ng => ngramCounts[ng] = (ngramCounts[ng] || 0) + 1;
  for (const w of words){
    const padded = ` ${w} `;
    for (let i = 0; i <= padded.length - n; i++) add(padded.slice(i, i + n));
  }
  const rarityScores = new Array(words.length);
  for (let i = 0; i < words.length; i++){
    const w = words[i];
    const padded = ` ${w} `;
    let sum = 0, count = 0;
    for (let j = 0; j <= padded.length - n; j++){
      const ng = padded.slice(j, j + n);
      sum += (ngramCounts[ng] || 0);
      count++;
    }
    const avg = (count ? sum / count : 0);
    const score = 1 / (avg + 1e-9);
    rarityScores[i] = score;
  }
  // compute thresholds
  const sortedScores = rarityScores.slice().sort((a,b)=>a-b);
  rarityThresholds.uncommon = quantile(sortedScores, RARITY_PERCENTILES.uncommon);
  rarityThresholds.rare     = quantile(sortedScores, RARITY_PERCENTILES.rare);
  rarityThresholds.epic     = quantile(sortedScores, RARITY_PERCENTILES.epic);
  rarityThresholds.legendary= quantile(sortedScores, RARITY_PERCENTILES.legendary);

  // assign to map
  const map = Object.create(null);
  for (let i = 0; i < words.length; i++){
    const w = words[i];
    const s = rarityScores[i];
    let bucket = 'common';
    if (s >= rarityThresholds.legendary) bucket = 'legendary';
    else if (s >= rarityThresholds.epic) bucket = 'epic';
    else if (s >= rarityThresholds.rare) bucket = 'rare';
    else if (s >= rarityThresholds.uncommon) bucket = 'uncommon';
    map[w] = { score: s, bucket };
  }
  return map;
}

function bytesForString(str){ return new Blob([str]).size; }

function tryLoadFromStorage(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    const parsed = JSON.parse(raw);
    if (!parsed || !parsed.mapVersion) return false;
    jsonRarityMap = parsed.jsonMap || null;
    jsonRarityMap = parsed.genMap || null;
    rarityThresholds = parsed.thresholds || {};
    console.log('Rarity: loaded from cache (jsonMap entries:', jsonRarityMap ? Object.keys(jsonRarityMap).length : 0, ', genMap entries:', jsonRarityMap ? Object.keys(jsonRarityMap).length : 0, ')');
    return true;
  } catch(e){ console.warn('Rarity cache load failed', e); return false; }
}

function trySaveToStorage(){
  try{
    const payload = { mapVersion: 1, jsonMap: jsonRarityMap || null, genMap: jsonRarityMap || null, thresholds: rarityThresholds };
    const s = JSON.stringify(payload);
    if (bytesForString(s) > MAX_LOCALSTORAGE_BYTES){ console.warn('Rarity map too large to cache (~' + bytesForString(s) + ' bytes)'); return false; }
    localStorage.setItem(STORAGE_KEY, s);
    console.log('Rarity: cached to localStorage');
    return true;
  } catch(e){ console.warn('Rarity cache save failed', e); return false; }
}

async function initRarityFromJSON(path = './rarity_map.json'){
  try{
    const resp = await fetch(path, { cache: 'no-cache' });
    if (!resp.ok) throw new Error('fetch failed: ' + resp.status);
    const j = await resp.json();
    if (!j) throw new Error('invalid json');
    // Accept either object { map: {...}, thresholds: {...} } or plain map
    jsonRarityMap = j.map || j || null;
    if (!jsonRarityMap) throw new Error('json contains no map');
    rarityThresholds = j.thresholds || rarityThresholds || {};
    trySaveToStorage();
    console.log('Rarity: loaded from JSON (', path, ') entries:', Object.keys(jsonRarityMap).length);
    return true;
  } catch (e){
    console.warn('initRarityFromJSON failed:', e);
    return false;
  }
}

async function initRarityFromWordlist(path = './wordlist.txt'){
  try{
    const resp = await fetch(path);
    if (!resp.ok) throw new Error('fetch failed');
    const txt = await resp.text();
    const words = txt.split(/\r?\n/).map(w=>w.trim().toLowerCase()).filter(Boolean);
    if (!words.length) throw new Error('empty wordlist');

    if (words.length > 200000) console.warn('Large wordlist detected (' + words.length + ' words) — building rarity map may take a few seconds in the browser.');
    const map = buildRarityFromWordlistNgramsSync(words, 3);
    // store generated map
    jsonRarityMap = Object.create(null);
    for (const w of words){ const entry = map[w]; if (!entry) continue; jsonRarityMap[w] = entry; }
    trySaveToStorage();
    console.log('Rarity: built from wordlist (n-gram proxy) entries:', Object.keys(jsonRarityMap).length);
    return true;
  } catch(e){
    console.warn('initRarityFromWordlist failed:', e);
    return false;
  }
}

async function initRarityPreferJSON(){
  // JSON-only behavior enforced: try cache, then try JSON from server. No fallback to wordlist.
  if (tryLoadFromStorage()) return true;
  const ok = await initRarityFromJSON('./rarity_map.json');
  return !!ok;
}

function computeRarity(word){
  if (!word) return 'common';
  const w = String(word).toLowerCase();
  // 1) Prefer json-provided rarity if present
  if (jsonRarityMap && jsonRarityMap[w]){
    return jsonRarityMap[w].bucket || (jsonRarityMap[w].bucket === undefined ? jsonRarityMap[w] : 'common');
  }
  // 2) Fall back to generated map
  if (jsonRarityMap && jsonRarityMap[w]) return jsonRarityMap[w].bucket;
  // 3) Fallback heuristics
  if (w.length <= 3) return 'common';
  if (w.length === 4) return 'uncommon';
  if (w.length === 5) return 'rare';
  if (w.length === 6) return 'epic';
  return 'legendary';
}

(function(){
  if (!window.__rarityInitStarted){
    window.__rarityInitStarted = true;
    setTimeout(()=>{
      initRarityPreferJSON().then(ok=>{ if (!ok) console.log('Rarity: using fallback heuristics'); });
    }, 120);
  }
})();

window.__gameRarity = window.__gameRarity || {};
Object.assign(window.__gameRarity, {
  getJsonMap: ()=>jsonRarityMap,
  getGenMap: ()=>jsonRarityMap,
  getThresholds: ()=>rarityThresholds,
  computeRarity,
  reloadFromJSON: async (url = './rarity_map.json')=>{ const ok = await initRarityFromJSON(url); if (ok) console.log('Rarity map reloaded from', url); return ok; },
  rebuildFromWordlist: async (url = './wordlist.txt')=>{ const ok = await initRarityFromWordlist(url); if (ok) console.log('Generated rarity rebuilt from', url); return ok; }
});

// Also keep a convenience alias used by other parts of the game
window.computeRarity = computeRarity;
</script>
<!-- END RARITY MODULE -->
</body>
</html>